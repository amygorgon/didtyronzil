{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tyronZIL DID method specification A W3C Sidetree-based DID method for the Zilliqa blockchain platform Developed by Julio Cabrapan Duarte Funded by ZILHive Conformance The tyronZIL DID method is conformant with the following specifications: i. World Wide Web Consortium (W3C) Decentralized Identifiers (DIDs) v1.0 ii. Decentralized Identity Foundation (DIF) Sidetree protocol Problem summary Identities on the internet remain centralized, mainly by identity providers such as Facebook, Google and PayPal. Thus, when people shop online and login with these accounts, they don't have enough control nor understanding of how their data is used and shared with third parties. Self-sovereign identity (SSI) allows people to manage their digital identities and prove who they are without a centralized authority, by anchoring decentralized identifiers (DIDs) on blockchain platforms. However, most DLTs still can't provide SSI applications at scale. By implementing the Sidetree protocol on top of Zilliqa, tyronZIL aims to solve this issue and enable user-controlled digital identities in the Zilliqa ecosystem. Index W3C DIDs Sidetree protocol and default parameters DID-document Scheme: DID-scheme DID URL syntax Operations: Introduction DID CRUD: Create Resolve Recover Update Deactivate Implementation: tyronZIL-js for Node.js > GitHub tyronZIL-js Sidetree models","title":"Home"},{"location":"#tyronzil-did-method-specification","text":"A W3C Sidetree-based DID method for the Zilliqa blockchain platform Developed by Julio Cabrapan Duarte Funded by ZILHive","title":"tyronZIL DID method specification"},{"location":"#conformance","text":"The tyronZIL DID method is conformant with the following specifications: i. World Wide Web Consortium (W3C) Decentralized Identifiers (DIDs) v1.0 ii. Decentralized Identity Foundation (DIF) Sidetree protocol","title":"Conformance"},{"location":"#problem-summary","text":"Identities on the internet remain centralized, mainly by identity providers such as Facebook, Google and PayPal. Thus, when people shop online and login with these accounts, they don't have enough control nor understanding of how their data is used and shared with third parties. Self-sovereign identity (SSI) allows people to manage their digital identities and prove who they are without a centralized authority, by anchoring decentralized identifiers (DIDs) on blockchain platforms. However, most DLTs still can't provide SSI applications at scale. By implementing the Sidetree protocol on top of Zilliqa, tyronZIL aims to solve this issue and enable user-controlled digital identities in the Zilliqa ecosystem.","title":"Problem summary"},{"location":"#index","text":"W3C DIDs Sidetree protocol and default parameters DID-document Scheme: DID-scheme DID URL syntax Operations: Introduction DID CRUD: Create Resolve Recover Update Deactivate Implementation: tyronZIL-js for Node.js > GitHub tyronZIL-js Sidetree models","title":"Index"},{"location":"W3C-dids/","text":"W3C DIDs The tyronZIL DID method conforms with the following terms specified in W3C Decentralized Identifiers (DIDs) v1.0 : DID method A DID method is the specification for the precise scheme of a DID, and it also specifies the methods creating, resolving, updating and deactivating such a DID and its DID document, using a specific type of verifiable data registry, in tyronZIL's case Zilliqa. Learn about the precise tyronZIL: - DID-scheme - DID-operations Decentralized Identifier (DID) A DID is a globally unique Uniform Resource Identifier (URI) that associates a DID subject with a DID document. Given the decentralized nature of Zilliqa, a tyronZIL DID has its existence guaranteed without depending on a central authority. A DID consists of three parts: The scheme identifier: \"did\" The DID method identifier The DID method-specific identifier, which must be unique DID URL A DID URL identifies a particular resource to be located, e.g. a specific part of the DID document. It extends the syntax of a basic DID to incorporate other standard URI components: Path: The portion of a DID URL that begins with and includes the first forward slash character, \"/\" Query: The portion of a DID URL that follows the first question mark character, \"?\" Fragment: The portion of a DID URL that follows the first hash sign character \"#\" DID subject The DID subject is the entity identified by the DID and described by the DID document. DID controller The DID controller is the entity that has the capability - as defined by the DID method - to make changes to a DID document. DID document A DID is resolvable to a DID document, which contains metadata associated with the DID, such as cryptographic material, verification methods and service endpoints relevant to interactions with the DID subject. The DID itself is the value of the id property. tyronZIL DID document Verification method A verification method is a set of parameters used to independently verify a proof according to the particular DID method, e.g. a public key. Verification relationship It expresses the relationship between the DID subject and a verification method, e.g. authentication. All verification methods must be associated with a particular verification relationship. Producer A producer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by generating conforming DIDs or conforming DID documents. A producer that is conformant with the specification MUST NOT produce non-conforming DIDs or DID documents. Producers MUST indicate which representation of a document corresponds via a media type in the document's metadata. Consumer A consumer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by consuming conforming DIDs or conforming DID documents. A consumer that is conformant with the specification MUST produce errors when consuming non-conforming DIDs or DID documents. Consumers MUST determine which is the representation of the DID document via the content-type DID resolver metadata field.","title":"W3C DIDs"},{"location":"W3C-dids/#w3c-dids","text":"The tyronZIL DID method conforms with the following terms specified in W3C Decentralized Identifiers (DIDs) v1.0 :","title":"W3C DIDs"},{"location":"W3C-dids/#did-method","text":"A DID method is the specification for the precise scheme of a DID, and it also specifies the methods creating, resolving, updating and deactivating such a DID and its DID document, using a specific type of verifiable data registry, in tyronZIL's case Zilliqa. Learn about the precise tyronZIL: - DID-scheme - DID-operations","title":"DID method"},{"location":"W3C-dids/#decentralized-identifier-did","text":"A DID is a globally unique Uniform Resource Identifier (URI) that associates a DID subject with a DID document. Given the decentralized nature of Zilliqa, a tyronZIL DID has its existence guaranteed without depending on a central authority. A DID consists of three parts: The scheme identifier: \"did\" The DID method identifier The DID method-specific identifier, which must be unique","title":"Decentralized Identifier (DID)"},{"location":"W3C-dids/#did-url","text":"A DID URL identifies a particular resource to be located, e.g. a specific part of the DID document. It extends the syntax of a basic DID to incorporate other standard URI components: Path: The portion of a DID URL that begins with and includes the first forward slash character, \"/\" Query: The portion of a DID URL that follows the first question mark character, \"?\" Fragment: The portion of a DID URL that follows the first hash sign character \"#\"","title":"DID URL"},{"location":"W3C-dids/#did-subject","text":"The DID subject is the entity identified by the DID and described by the DID document.","title":"DID subject"},{"location":"W3C-dids/#did-controller","text":"The DID controller is the entity that has the capability - as defined by the DID method - to make changes to a DID document.","title":"DID controller"},{"location":"W3C-dids/#did-document","text":"A DID is resolvable to a DID document, which contains metadata associated with the DID, such as cryptographic material, verification methods and service endpoints relevant to interactions with the DID subject. The DID itself is the value of the id property. tyronZIL DID document","title":"DID document"},{"location":"W3C-dids/#verification-method","text":"A verification method is a set of parameters used to independently verify a proof according to the particular DID method, e.g. a public key.","title":"Verification method"},{"location":"W3C-dids/#verification-relationship","text":"It expresses the relationship between the DID subject and a verification method, e.g. authentication. All verification methods must be associated with a particular verification relationship.","title":"Verification relationship"},{"location":"W3C-dids/#producer","text":"A producer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by generating conforming DIDs or conforming DID documents. A producer that is conformant with the specification MUST NOT produce non-conforming DIDs or DID documents. Producers MUST indicate which representation of a document corresponds via a media type in the document's metadata.","title":"Producer"},{"location":"W3C-dids/#consumer","text":"A consumer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by consuming conforming DIDs or conforming DID documents. A consumer that is conformant with the specification MUST produce errors when consuming non-conforming DIDs or DID documents. Consumers MUST determine which is the representation of the DID document via the content-type DID resolver metadata field.","title":"Consumer"},{"location":"did-document/","text":"tyronZIL DID document For an introduction, read this A DID-document is a graph-based data structure, a collection of property-value pairs, serialized according to a particular syntax. TyronZIL's serialization format is JSON: It defines an unambiguous encoding and decoding of all properties and their associated values It MUST be a single JSON object conforming to RFC8259, The JavaScript Object Notation (JSON) Data Interchange Format The names of the members of the JSON object MUST correspond to the core property names of the DID-document Property values MUST be: - Numbers for number values representable as IEEE754 - Literal values for boolean ('false', 'true') and empty values ('null') - Arrays for sequence values and unordered sets of values - Objects for sets of properties - Strings for all other values. Consumers MAY further parse these strings into more specific data types such as URIs and date stamps The content-type property in the resolver's metadata MUST be application/did+json : - Which is the associated IANA-registered MIME type, with its corresponding rules to process the fragment - Producers MUST write this type in the document's metadata, and consumers MUST validate it as well Consumers MUST ignore unknown object member names as unknown properties Core properties id The id value MUST be a single valid tyronZIL DID itself, e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\" } All W3C DID documents MUST include the \"id\" property, which denotes the DID subject . publicKey The publicKey property is one of the three supported verification methods , the other two being operation and recovery . The publicKey value MUST be an array of objects of type [VerificationMethodModel(./implementation/models.md#verification-method-model), e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\", \"publicKey\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ksEhVIcb7JGKp_zNL0NJJxFBNzGgERzSQrZjEfkvPJc\", \"y\": \"J3h3PgSqdUXkDt1CIZHbWmKvhlD1bedJX6VE3u1o7bE\", \"kid\": \"G0cATxTiiCC4Xt3NnANRCrfBOexYpQhB0Sy616E5LTE\" } }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#anotherSigningKey\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ynsq5eFLNaV-rIJxpT_QMBZ3dXv2kQwHzw7VZKjU8fs\", \"y\": \"q_Nw9PhUkWpt0mV5C62qydBokP09p8gkSKy9nFNTq60\", \"kid\": \"ofnZh1sI0we7eYfiDfIxcqK10NezOLvcQfCEBacbzOQ\" } } ] } operation The Sidetree protocol requires the verification methods 'operation' and 'recovery' , which correspond to the update and recovery commitment, respectively. The operation value MUST be an object of type [VerificationMethodModel(./implementation/models.md#verification-method-model) OR an empty value ('null') after deactivation, e.g.: { \"operation\": { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#-reKn00OlXduVOqrPtxB2_wsO0dJGaJsJX7ONxlpojg\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"qvPcMNez90MzDLgv0FYs3fzSNMowkkOVGYGR8d2P8p4\", \"y\": \"64TifxdUbqjrajAlfLEP6_SYn1uomge9rIW_uH8p6XM\", \"kid\": \"-reKn00OlXduVOqrPtxB2_wsO0dJGaJsJX7ONxlpojg\" } } } recovery The recovery value MUST be an object of type [VerificationMethodModel(./implementation/models.md#verification-method-model) OR an empty value ('null') after deactivation, e.g.: { \"recovery\": { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#cRvb0PTPB4DZR0RRbsmVrzi0Y592gHfKqcsurxGfjJs\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"-EFWN26jzAMk8LXFPU8Jw5YX-r1_avdB5lhD2eagJP4\", \"y\": \"XvJ5qYBSiXPv09y_M1C2IobbGxMdJlDySwNeGEd4p84\", \"kid\": \"cRvb0PTPB4DZR0RRbsmVrzi0Y592gHfKqcsurxGfjJs\" } } } All verification methods MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID URL. There MUST NOT be multiple verification method objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be exactly one verification method type. The default type is currently EcdsaSecp256k1VerificationKey2019 \"controller\": Its value MUST be a valid tyronZIL DID representing the entity that controls the corresponding private key \"jwk\": The cryptographic key itself expressed as a IETF RFC 7517 compliant JSON Web Key (JWK) representation for the KEY_ALGORITHM Before processing them into the DID-document, each verification method has a property called purpose . It states the functionality of the key, its verification relationship . For public keys, the purpose value MUST be an array of PublicKeyPurpose variants . For the verification methods operation and recovery , the purpose value MUST be the corresponding variant of the SidetreeVerificationRelationship enum . authentication At least one public key MUST have its purpose as PublicKeyPurpose.Auth = 'auth' . The authentication value MUST be an array of verification methods. Each verification method MAY be embedded or referenced, e.g.: { \"authentication\": [ // referenced key: \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", // embedded key: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#authentication-key\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"W5-Wa5xk6rtIyC4b0cp3JAb8-Rmhc_CIRPt-JPexZWY\", \"y\": \"XD15geXy_UBRByhnI_fuAZhvWSsaYR0L92jTLr63xk8\", \"kid\": \"Juvzhd0beV-bR8Oq12JYt4wyYYZ8Zndrb9oM_WMxoF4\" } } ] } Service endpoints tyronZIL service endpoints are used to express ways of communicating with the DID subject , from privacy preserving messaging services to cryptocurrency addresses. The service value MUST be an array of objects of type ServiceEndpointModel , e.g.: { \"service\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#tyronZIL-website\", \"type\": \"method-specification\", \"endpoint\": \"https://tyronZIL.com\" }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#ZIL-address\", \"type\": \"cryptocurrency-address\", \"endpoint\": \"zil1egvj6ketfydy48uqzu8qphhj5w4xrkratv85ht\" } ] } All services MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID URL with a length no more than fifty (50) ASCII encoded characters. There MUST NOT be multiple service objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be a string with a length of no more than thirty (30) ASCII encoded characters \"endpoint\": Its value MUST be a valid URI string (including a scheme segment: i.e. http://, git://) OR a cryptocurrency address, with a length of no more than one hundred (100) ASCII encoded characters If any of the values exceed the specified lengths, the consumer MUST produce an error.","title":"DID-document"},{"location":"did-document/#tyronzil-did-document","text":"For an introduction, read this A DID-document is a graph-based data structure, a collection of property-value pairs, serialized according to a particular syntax. TyronZIL's serialization format is JSON: It defines an unambiguous encoding and decoding of all properties and their associated values It MUST be a single JSON object conforming to RFC8259, The JavaScript Object Notation (JSON) Data Interchange Format The names of the members of the JSON object MUST correspond to the core property names of the DID-document Property values MUST be: - Numbers for number values representable as IEEE754 - Literal values for boolean ('false', 'true') and empty values ('null') - Arrays for sequence values and unordered sets of values - Objects for sets of properties - Strings for all other values. Consumers MAY further parse these strings into more specific data types such as URIs and date stamps The content-type property in the resolver's metadata MUST be application/did+json : - Which is the associated IANA-registered MIME type, with its corresponding rules to process the fragment - Producers MUST write this type in the document's metadata, and consumers MUST validate it as well Consumers MUST ignore unknown object member names as unknown properties","title":"tyronZIL DID document"},{"location":"did-document/#core-properties","text":"","title":"Core properties"},{"location":"did-document/#id","text":"The id value MUST be a single valid tyronZIL DID itself, e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\" } All W3C DID documents MUST include the \"id\" property, which denotes the DID subject .","title":"id"},{"location":"did-document/#publickey","text":"The publicKey property is one of the three supported verification methods , the other two being operation and recovery . The publicKey value MUST be an array of objects of type [VerificationMethodModel(./implementation/models.md#verification-method-model), e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\", \"publicKey\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ksEhVIcb7JGKp_zNL0NJJxFBNzGgERzSQrZjEfkvPJc\", \"y\": \"J3h3PgSqdUXkDt1CIZHbWmKvhlD1bedJX6VE3u1o7bE\", \"kid\": \"G0cATxTiiCC4Xt3NnANRCrfBOexYpQhB0Sy616E5LTE\" } }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#anotherSigningKey\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ynsq5eFLNaV-rIJxpT_QMBZ3dXv2kQwHzw7VZKjU8fs\", \"y\": \"q_Nw9PhUkWpt0mV5C62qydBokP09p8gkSKy9nFNTq60\", \"kid\": \"ofnZh1sI0we7eYfiDfIxcqK10NezOLvcQfCEBacbzOQ\" } } ] }","title":"publicKey"},{"location":"did-document/#operation","text":"The Sidetree protocol requires the verification methods 'operation' and 'recovery' , which correspond to the update and recovery commitment, respectively. The operation value MUST be an object of type [VerificationMethodModel(./implementation/models.md#verification-method-model) OR an empty value ('null') after deactivation, e.g.: { \"operation\": { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#-reKn00OlXduVOqrPtxB2_wsO0dJGaJsJX7ONxlpojg\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"qvPcMNez90MzDLgv0FYs3fzSNMowkkOVGYGR8d2P8p4\", \"y\": \"64TifxdUbqjrajAlfLEP6_SYn1uomge9rIW_uH8p6XM\", \"kid\": \"-reKn00OlXduVOqrPtxB2_wsO0dJGaJsJX7ONxlpojg\" } } }","title":"operation"},{"location":"did-document/#recovery","text":"The recovery value MUST be an object of type [VerificationMethodModel(./implementation/models.md#verification-method-model) OR an empty value ('null') after deactivation, e.g.: { \"recovery\": { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#cRvb0PTPB4DZR0RRbsmVrzi0Y592gHfKqcsurxGfjJs\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"-EFWN26jzAMk8LXFPU8Jw5YX-r1_avdB5lhD2eagJP4\", \"y\": \"XvJ5qYBSiXPv09y_M1C2IobbGxMdJlDySwNeGEd4p84\", \"kid\": \"cRvb0PTPB4DZR0RRbsmVrzi0Y592gHfKqcsurxGfjJs\" } } } All verification methods MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID URL. There MUST NOT be multiple verification method objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be exactly one verification method type. The default type is currently EcdsaSecp256k1VerificationKey2019 \"controller\": Its value MUST be a valid tyronZIL DID representing the entity that controls the corresponding private key \"jwk\": The cryptographic key itself expressed as a IETF RFC 7517 compliant JSON Web Key (JWK) representation for the KEY_ALGORITHM Before processing them into the DID-document, each verification method has a property called purpose . It states the functionality of the key, its verification relationship . For public keys, the purpose value MUST be an array of PublicKeyPurpose variants . For the verification methods operation and recovery , the purpose value MUST be the corresponding variant of the SidetreeVerificationRelationship enum .","title":"recovery"},{"location":"did-document/#authentication","text":"At least one public key MUST have its purpose as PublicKeyPurpose.Auth = 'auth' . The authentication value MUST be an array of verification methods. Each verification method MAY be embedded or referenced, e.g.: { \"authentication\": [ // referenced key: \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", // embedded key: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#authentication-key\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"W5-Wa5xk6rtIyC4b0cp3JAb8-Rmhc_CIRPt-JPexZWY\", \"y\": \"XD15geXy_UBRByhnI_fuAZhvWSsaYR0L92jTLr63xk8\", \"kid\": \"Juvzhd0beV-bR8Oq12JYt4wyYYZ8Zndrb9oM_WMxoF4\" } } ] }","title":"authentication"},{"location":"did-document/#service-endpoints","text":"tyronZIL service endpoints are used to express ways of communicating with the DID subject , from privacy preserving messaging services to cryptocurrency addresses. The service value MUST be an array of objects of type ServiceEndpointModel , e.g.: { \"service\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#tyronZIL-website\", \"type\": \"method-specification\", \"endpoint\": \"https://tyronZIL.com\" }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#ZIL-address\", \"type\": \"cryptocurrency-address\", \"endpoint\": \"zil1egvj6ketfydy48uqzu8qphhj5w4xrkratv85ht\" } ] } All services MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID URL with a length no more than fifty (50) ASCII encoded characters. There MUST NOT be multiple service objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be a string with a length of no more than thirty (30) ASCII encoded characters \"endpoint\": Its value MUST be a valid URI string (including a scheme segment: i.e. http://, git://) OR a cryptocurrency address, with a length of no more than one hundred (100) ASCII encoded characters If any of the values exceed the specified lengths, the consumer MUST produce an error.","title":"Service endpoints"},{"location":"sidetree/","text":"Sidetree protocol Here you can learn about the Sidetree protocol terminology and the default parameters in tyronZIL's implementation. Sidetree DID operation A Sidetree DID operation is a set of delta-based modifications that change the state of a DID document when applied. The maximum uncompressed operation size (MAX_OPERATION_SIZE) has a default parameter of 1 kb. Sidetree operation request JWS formatted request sent to a client to include a Sidetree DID operation in a batch of operations. Sidetree transaction A Sidetree transaction writes an Anchor string in a DLT transaction of the underlying ledger. tyronZIL transaction A tyronZIL transaction is a Sidetree transaction on the Zilliqa blockchain platform. Anchor string A Sidetree Anchor string is the string anchored to the ledger, composed of the CAS URI of an Anchor file prefixed with the declared operation count. The maximum number of operations per batch (MAX_OPERATION_COUNT) has a default parameter of 10,000. Sidetree transaction number The Sidetreee transaction number is a monotonically increasing number. Its order is deterministic and assigned to every transaction according to its position in the ledger time. Ledger time The ledger time is the blockchain clock variable, used as a deterministic chronological reference. Anchor file An Anchor file is a JSON document containing proving and index data for the create, recovery and deactivate operations, as well as a CAS URI for the associated Map file. This file is anchored to the Zilliqa blockchain through a Sidetree transaction . The maximum size of a compressed Anchor file (MAX_ANCHOR_FILE_SIZE) has a default parameter of 1 MB. Map file A Map file is a JSON document containing proving and index data for the DID-update operation, as well as a CAS URI for the associated Chunk file. The maximum size of a compressed Map file (MAX_MAP_FILE_SIZE) has a default parameter of 1 MB. Chunk file A Chunk file is a JSON document containing all the operation delta objects corresponding to the set of DIDs specified in the Map file. The maximum size of a compressed Chunk file (MAX_CHUNK_FILE_SIZE) has a default parameter of 10 MB. CAS CAS stands for content-addressable storage. The CAS protocol utilized by tyronZIL is IPFS . CAS URI A CAS URI is a unique content-bound identifier used to locate a specific resource via the CAS protocol. The default CAS_URI_ALGORITHM to generate the CAS URI is IPFS CID. DID suffix A DID suffix is the unique identifier string in a Decentralized Identifier, the last part of the DID after the final colon. Hash algorithm The HASH_ALGORITH is the algorithm to generate hashes of protocol-related values. The default parameter is SHA256. Hash protocol The HASH_PROTOCOL is the protocol to generate hash representations using the HASH_ALGORITHM. The default parameter is Multihash : a protocol for differentiating outputs from various cryptographic hash functions, addressing size and encoding considerations. Data encoding scheme The DATA_ENCODING_SCHEME is the encoding for various data structures such as JSON and hashes, which MUST have its output in ASCII format. The default parameter is Base64URL. Key algorithm The KEY_ALGORITHM is the asymmetric public key algorithm to sign DID operations, which MUST be a valid JWK \"crv\". The default parameter is secp256k1. Operation key pair Generates a cryptographic key pair to operate with, using the KEY_ALGORITHM. It returns the public key as a PublicKeyModel and the private key as a secp256k1 key of type JwkEs256k . Public key commitment It is the resulting commitment obtained by applying the defined commitment scheme to a public key. Update-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of an update key pair. Recovery-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of a recovery key pair. Commitment scheme A cryptographic primitive that commits to a chosen value, known as the commit value resulting in the generation of a commitment. Then, that commitment written in the DID document acts as a proof-of-commitment, without revealing the secret. The possessor of the corresponding private key can later use the commit value, to prove the right signature over the original commitment. Public key commitment scheme Commitment scheme steps to generate a public key commitment from a public key: Encode the public key into the form of a valid JWK Canonicalize the JWK encoded public key using the JSON Canonicalization Scheme Apply the defined HASH_ALGORITHM to the canonicalized public key to produce the public key commitment Implementers MUST NOT re-use public keys across different commitment invocations. Signature algorithm The SIGNATURE_ALGORITHM is the asymmetric public key signature algorithm, which MUST be a valid JWS \"alg\". The default parameter is ES256K. Commitment hash The COMMITMENT_HASH is a cryptographically random hash of a value to be revealed in the next operation. The default parameter is 32 bytes. DID state patch A DID state patch is the Sidetree format to describe the mutations of the DID's metadata state. Its data structure corresponds with the Patch model , which MUST include a Patch action and the document to be patched. Sidetree verification relationships As defined in W3C verification relationship , the Sidetree protocol requires the following verification relationships: enum SidetreeVerificationRelationship { Operation = 'operation', Recovery = 'recovery' } Operation: This verification relationship corresponds to a verification method of type update key, the key used to create the update-commitment , required by the DID-update operation . Recovery: This verification relationship corresponds to a verification method of type recovery key, the key used to create the recovery-commitment , required by the operations DID-recover and DID-deactivate .","title":"Sidetree protocol"},{"location":"sidetree/#sidetree-protocol","text":"Here you can learn about the Sidetree protocol terminology and the default parameters in tyronZIL's implementation.","title":"Sidetree protocol"},{"location":"sidetree/#sidetree-did-operation","text":"A Sidetree DID operation is a set of delta-based modifications that change the state of a DID document when applied. The maximum uncompressed operation size (MAX_OPERATION_SIZE) has a default parameter of 1 kb.","title":"Sidetree DID operation"},{"location":"sidetree/#sidetree-operation-request","text":"JWS formatted request sent to a client to include a Sidetree DID operation in a batch of operations.","title":"Sidetree operation request"},{"location":"sidetree/#sidetree-transaction","text":"A Sidetree transaction writes an Anchor string in a DLT transaction of the underlying ledger.","title":"Sidetree transaction"},{"location":"sidetree/#tyronzil-transaction","text":"A tyronZIL transaction is a Sidetree transaction on the Zilliqa blockchain platform.","title":"tyronZIL transaction"},{"location":"sidetree/#anchor-string","text":"A Sidetree Anchor string is the string anchored to the ledger, composed of the CAS URI of an Anchor file prefixed with the declared operation count. The maximum number of operations per batch (MAX_OPERATION_COUNT) has a default parameter of 10,000.","title":"Anchor string"},{"location":"sidetree/#sidetree-transaction-number","text":"The Sidetreee transaction number is a monotonically increasing number. Its order is deterministic and assigned to every transaction according to its position in the ledger time.","title":"Sidetree transaction number"},{"location":"sidetree/#ledger-time","text":"The ledger time is the blockchain clock variable, used as a deterministic chronological reference.","title":"Ledger time"},{"location":"sidetree/#anchor-file","text":"An Anchor file is a JSON document containing proving and index data for the create, recovery and deactivate operations, as well as a CAS URI for the associated Map file. This file is anchored to the Zilliqa blockchain through a Sidetree transaction . The maximum size of a compressed Anchor file (MAX_ANCHOR_FILE_SIZE) has a default parameter of 1 MB.","title":"Anchor file"},{"location":"sidetree/#map-file","text":"A Map file is a JSON document containing proving and index data for the DID-update operation, as well as a CAS URI for the associated Chunk file. The maximum size of a compressed Map file (MAX_MAP_FILE_SIZE) has a default parameter of 1 MB.","title":"Map file"},{"location":"sidetree/#chunk-file","text":"A Chunk file is a JSON document containing all the operation delta objects corresponding to the set of DIDs specified in the Map file. The maximum size of a compressed Chunk file (MAX_CHUNK_FILE_SIZE) has a default parameter of 10 MB.","title":"Chunk file"},{"location":"sidetree/#cas","text":"CAS stands for content-addressable storage. The CAS protocol utilized by tyronZIL is IPFS .","title":"CAS"},{"location":"sidetree/#cas-uri","text":"A CAS URI is a unique content-bound identifier used to locate a specific resource via the CAS protocol. The default CAS_URI_ALGORITHM to generate the CAS URI is IPFS CID.","title":"CAS URI"},{"location":"sidetree/#did-suffix","text":"A DID suffix is the unique identifier string in a Decentralized Identifier, the last part of the DID after the final colon.","title":"DID suffix"},{"location":"sidetree/#hash-algorithm","text":"The HASH_ALGORITH is the algorithm to generate hashes of protocol-related values. The default parameter is SHA256.","title":"Hash algorithm"},{"location":"sidetree/#hash-protocol","text":"The HASH_PROTOCOL is the protocol to generate hash representations using the HASH_ALGORITHM. The default parameter is Multihash : a protocol for differentiating outputs from various cryptographic hash functions, addressing size and encoding considerations.","title":"Hash protocol"},{"location":"sidetree/#data-encoding-scheme","text":"The DATA_ENCODING_SCHEME is the encoding for various data structures such as JSON and hashes, which MUST have its output in ASCII format. The default parameter is Base64URL.","title":"Data encoding scheme"},{"location":"sidetree/#key-algorithm","text":"The KEY_ALGORITHM is the asymmetric public key algorithm to sign DID operations, which MUST be a valid JWK \"crv\". The default parameter is secp256k1.","title":"Key algorithm"},{"location":"sidetree/#operation-key-pair","text":"Generates a cryptographic key pair to operate with, using the KEY_ALGORITHM. It returns the public key as a PublicKeyModel and the private key as a secp256k1 key of type JwkEs256k .","title":"Operation key pair"},{"location":"sidetree/#public-key-commitment","text":"It is the resulting commitment obtained by applying the defined commitment scheme to a public key. Update-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of an update key pair. Recovery-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of a recovery key pair.","title":"Public key commitment"},{"location":"sidetree/#commitment-scheme","text":"A cryptographic primitive that commits to a chosen value, known as the commit value resulting in the generation of a commitment. Then, that commitment written in the DID document acts as a proof-of-commitment, without revealing the secret. The possessor of the corresponding private key can later use the commit value, to prove the right signature over the original commitment.","title":"Commitment scheme"},{"location":"sidetree/#public-key-commitment-scheme","text":"Commitment scheme steps to generate a public key commitment from a public key: Encode the public key into the form of a valid JWK Canonicalize the JWK encoded public key using the JSON Canonicalization Scheme Apply the defined HASH_ALGORITHM to the canonicalized public key to produce the public key commitment Implementers MUST NOT re-use public keys across different commitment invocations.","title":"Public key commitment scheme"},{"location":"sidetree/#signature-algorithm","text":"The SIGNATURE_ALGORITHM is the asymmetric public key signature algorithm, which MUST be a valid JWS \"alg\". The default parameter is ES256K.","title":"Signature algorithm"},{"location":"sidetree/#commitment-hash","text":"The COMMITMENT_HASH is a cryptographically random hash of a value to be revealed in the next operation. The default parameter is 32 bytes.","title":"Commitment hash"},{"location":"sidetree/#did-state-patch","text":"A DID state patch is the Sidetree format to describe the mutations of the DID's metadata state. Its data structure corresponds with the Patch model , which MUST include a Patch action and the document to be patched.","title":"DID state patch"},{"location":"sidetree/#sidetree-verification-relationships","text":"As defined in W3C verification relationship , the Sidetree protocol requires the following verification relationships: enum SidetreeVerificationRelationship { Operation = 'operation', Recovery = 'recovery' } Operation: This verification relationship corresponds to a verification method of type update key, the key used to create the update-commitment , required by the DID-update operation . Recovery: This verification relationship corresponds to a verification method of type recovery key, the key used to create the recovery-commitment , required by the operations DID-recover and DID-deactivate .","title":"Sidetree verification relationships"},{"location":"implementation/models/","text":"tyronZIL-js Sidetree models tyronZIL-js is the open-source reference implementation for Node.js, written in TypeScript. The Sidetree protocol requires the following data structures: JwkEs256k Model to represent a secp256k1 key in a JWK format: interface JwkEs256k { kty: string; crv: string; x: string; y: string; kid?: string; d?: string; // Only used by a private key } Verification method model interface VerificationMethodModel { id: string; type: string; controller?: string; jwk: JwkEs256k; } Public key model interface PublicKeyModel { id: string; type: string; controller?: string; jwk: JwkEs256k; purpose: PublicKeyPurpose[]; } The type defaults to 'EcdsaSecp256k1VerificationKey2019'. Public key purpose enum PublicKeyPurpose { General = 'general', Auth = 'auth', Agreement = 'agreement', Assertion = 'assertion', Delegation = 'delegation', Invocation = 'invocation' } Sidetree verification methods Sidetree requires these verification methods to fulfil the Sidetree verification relationships : interface Operation { id: string // TyronZILScheme.did_tyronZIL + '#' + 'UPDATE_KEY'; type: string; controller?: string; jwk: UPDATE_KEY; purpose: SidetreeVerificationRelationship.Operation; } interface Recovery { id: string // TyronZILScheme.did_tyronZIL + '#' + RECOVERY_KEY; type: string; controller?: string; jwk: RECOVERY_KEY; purpose: SidetreeVerificationRelationship.Recover; } The UPDATE_KEY and RECOVERY_KEY are of type JwkEs256k and correspond to the update and recovery commitment , respectively. The type defaults to 'EcdsaSecp256k1VerificationKey2019'. Service endpoint model interface ServiceEndpointModel { id: string; type: string; endpoint: string; } Document model interface DocumentModel { public_keys: PublicKeyModel[]; service_endpoints?: ServiceEndpointModel[]; } Patch model interface PatchModel { action: PatchAction; publicKeys?: PublicKeyModel[]; serviceEndpoints?: ServiceEndpointModel[]; ids?: string[]; document: DocumentModel; } Patch action enum PatchAction { Replace = 'replace', AddKeys = 'add-public-keys', RemoveKeys = 'remove-public-keys', AddServices = 'add-service-endpoints', RemoveServices = 'remove-service-endpoints', CustomAction = '-custom-action', } Replace acts as a complete state reset that replaces a DID's current PKI metadata with the state provided - also used to create new DIDs. Delta model interface DeltaModel { patches: PatchModel[]; update_commitment: string; } Suffix data model interface SuffixDataModel { /** Encoded representation of the Create Operation Delta Object */ delta_hash: string; recovery_commitment: string; } Signed data models Define the model for the JWS payload object required by the Update, Recover and Deactivate Operation Signed Data Object, respectively. Update interface UpdateSignedDataModel { // Encoded representation of the Update Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous update commitment value update_key: JwkEs256k; } Recover export interface RecoverSignedDataModel { // Encoded representation of the Recovery Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; // A new recovery commitment for the next recover operation recovery_commitment: string; } Deactivate export interface DeactivateSignedDataModel { // The unique suffix of the DID to deactivate did_suffix: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; } DID state interface DidStateModel { document: DocumentModel; updateCommitment: string | undefined; recoverCommitment: string | undefined; lastTransactionNumber?: number; } The commitments are undefined after the deactivate operation. Anchored operation model interface AnchoredOperationModel { // The original request buffer sent by the requester operationBuffer: Buffer; // The DID unique suffix didUniqueSuffix: string; // The type of operation type: OperationType; // The logical blockchain time that this operation was anchored on the blockchain ledgerTime: number; // The transaction number of the transaction this operation was batched within transactionNumber: number; // The index this operation was assigned to in the batch operationIndex: number; }","title":"tyronZIL-js models"},{"location":"implementation/models/#tyronzil-js-sidetree-models","text":"tyronZIL-js is the open-source reference implementation for Node.js, written in TypeScript. The Sidetree protocol requires the following data structures:","title":"tyronZIL-js Sidetree models"},{"location":"implementation/models/#jwkes256k","text":"Model to represent a secp256k1 key in a JWK format: interface JwkEs256k { kty: string; crv: string; x: string; y: string; kid?: string; d?: string; // Only used by a private key }","title":"JwkEs256k"},{"location":"implementation/models/#verification-method-model","text":"interface VerificationMethodModel { id: string; type: string; controller?: string; jwk: JwkEs256k; }","title":"Verification method model"},{"location":"implementation/models/#public-key-model","text":"interface PublicKeyModel { id: string; type: string; controller?: string; jwk: JwkEs256k; purpose: PublicKeyPurpose[]; } The type defaults to 'EcdsaSecp256k1VerificationKey2019'.","title":"Public key model"},{"location":"implementation/models/#public-key-purpose","text":"enum PublicKeyPurpose { General = 'general', Auth = 'auth', Agreement = 'agreement', Assertion = 'assertion', Delegation = 'delegation', Invocation = 'invocation' }","title":"Public key purpose"},{"location":"implementation/models/#sidetree-verification-methods","text":"Sidetree requires these verification methods to fulfil the Sidetree verification relationships : interface Operation { id: string // TyronZILScheme.did_tyronZIL + '#' + 'UPDATE_KEY'; type: string; controller?: string; jwk: UPDATE_KEY; purpose: SidetreeVerificationRelationship.Operation; } interface Recovery { id: string // TyronZILScheme.did_tyronZIL + '#' + RECOVERY_KEY; type: string; controller?: string; jwk: RECOVERY_KEY; purpose: SidetreeVerificationRelationship.Recover; } The UPDATE_KEY and RECOVERY_KEY are of type JwkEs256k and correspond to the update and recovery commitment , respectively. The type defaults to 'EcdsaSecp256k1VerificationKey2019'.","title":"Sidetree verification methods"},{"location":"implementation/models/#service-endpoint-model","text":"interface ServiceEndpointModel { id: string; type: string; endpoint: string; }","title":"Service endpoint model"},{"location":"implementation/models/#document-model","text":"interface DocumentModel { public_keys: PublicKeyModel[]; service_endpoints?: ServiceEndpointModel[]; }","title":"Document model"},{"location":"implementation/models/#patch-model","text":"interface PatchModel { action: PatchAction; publicKeys?: PublicKeyModel[]; serviceEndpoints?: ServiceEndpointModel[]; ids?: string[]; document: DocumentModel; }","title":"Patch model"},{"location":"implementation/models/#patch-action","text":"enum PatchAction { Replace = 'replace', AddKeys = 'add-public-keys', RemoveKeys = 'remove-public-keys', AddServices = 'add-service-endpoints', RemoveServices = 'remove-service-endpoints', CustomAction = '-custom-action', } Replace acts as a complete state reset that replaces a DID's current PKI metadata with the state provided - also used to create new DIDs.","title":"Patch action"},{"location":"implementation/models/#delta-model","text":"interface DeltaModel { patches: PatchModel[]; update_commitment: string; }","title":"Delta model"},{"location":"implementation/models/#suffix-data-model","text":"interface SuffixDataModel { /** Encoded representation of the Create Operation Delta Object */ delta_hash: string; recovery_commitment: string; }","title":"Suffix data model"},{"location":"implementation/models/#signed-data-models","text":"Define the model for the JWS payload object required by the Update, Recover and Deactivate Operation Signed Data Object, respectively.","title":"Signed data models"},{"location":"implementation/models/#update","text":"interface UpdateSignedDataModel { // Encoded representation of the Update Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous update commitment value update_key: JwkEs256k; }","title":"Update"},{"location":"implementation/models/#recover","text":"export interface RecoverSignedDataModel { // Encoded representation of the Recovery Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; // A new recovery commitment for the next recover operation recovery_commitment: string; }","title":"Recover"},{"location":"implementation/models/#deactivate","text":"export interface DeactivateSignedDataModel { // The unique suffix of the DID to deactivate did_suffix: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; }","title":"Deactivate"},{"location":"implementation/models/#did-state","text":"interface DidStateModel { document: DocumentModel; updateCommitment: string | undefined; recoverCommitment: string | undefined; lastTransactionNumber?: number; } The commitments are undefined after the deactivate operation.","title":"DID state"},{"location":"implementation/models/#anchored-operation-model","text":"interface AnchoredOperationModel { // The original request buffer sent by the requester operationBuffer: Buffer; // The DID unique suffix didUniqueSuffix: string; // The type of operation type: OperationType; // The logical blockchain time that this operation was anchored on the blockchain ledgerTime: number; // The transaction number of the transaction this operation was batched within transactionNumber: number; // The index this operation was assigned to in the batch operationIndex: number; }","title":"Anchored operation model"},{"location":"operations/tyronZIL-operations/","text":"tyronZIL DID-operations The tyronZIL DID client performs the following operations: Create Read Recover Update Deactivate Create How to generate a DID and its associated DID document. Details at tyronZIL DID-create Read How to use a DID to request its DID document. This operation corresponds to the DID resolution process. Update How to update a DID document, including the cryptographic operations necessary to establish proof of control. Details at tyronZIL DID-update Recover To fully reset your DID document while keeping the same DID. Details at tyronZIL DID-recover Deactivate To deactivate a DID, including the cryptographic operations necessary to establish proof of deactivation. Details at tyronZIL DID-deactivate Sidetree operation type Conforming with the Sidetree protocol, tyronZIL DID operations MUST have a type equal to one variant of the OperationType enum, defined as follows: enum OperationType { Create = 'create', Recover = 'recover' Update = 'update', Deactivate = 'deactivate', }","title":"Introduction"},{"location":"operations/tyronZIL-operations/#tyronzil-did-operations","text":"The tyronZIL DID client performs the following operations: Create Read Recover Update Deactivate","title":"tyronZIL DID-operations"},{"location":"operations/tyronZIL-operations/#create","text":"How to generate a DID and its associated DID document. Details at tyronZIL DID-create","title":"Create"},{"location":"operations/tyronZIL-operations/#read","text":"How to use a DID to request its DID document. This operation corresponds to the DID resolution process.","title":"Read"},{"location":"operations/tyronZIL-operations/#update","text":"How to update a DID document, including the cryptographic operations necessary to establish proof of control. Details at tyronZIL DID-update","title":"Update"},{"location":"operations/tyronZIL-operations/#recover","text":"To fully reset your DID document while keeping the same DID. Details at tyronZIL DID-recover","title":"Recover"},{"location":"operations/tyronZIL-operations/#deactivate","text":"To deactivate a DID, including the cryptographic operations necessary to establish proof of deactivation. Details at tyronZIL DID-deactivate","title":"Deactivate"},{"location":"operations/tyronZIL-operations/#sidetree-operation-type","text":"Conforming with the Sidetree protocol, tyronZIL DID operations MUST have a type equal to one variant of the OperationType enum, defined as follows: enum OperationType { Create = 'create', Recover = 'recover' Update = 'update', Deactivate = 'deactivate', }","title":"Sidetree operation type"},{"location":"operations/CRUD/did-create/","text":"tyronZIL DID-create operation A tyronZIL DID-create operation is conformant with a Sidetree Create operation, and its goal is to generate a brand new tyronZIL Decentralized Identifier. Follow these steps: 1. Verification methods tyronZIL supports 3 verification methods: 'publicKey', 'operation' and 'recovery'. 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[] 1.2 Under the property 'operation', assign to its value an Operation verification method object: operation: Operation 1.3 Under the property 'recovery', assign to its value a Recovery verification method object: recovery: Recovery 2. Public key commitments 2.1 For the public key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY ) 3. Service endpoints Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[] 4. Document model Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service } 5. DID state patch Put the previously generated document inside of a DID state patch . For the DID-create operation, the patch action is 'replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction 6. Create Operation Delta Object 6.1 Using the DID state patch and the update-commitment, generate an instance of the Create Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol and then encode it again as DELTA_HASH 7. Create Operation Suffix Data Object 7.1 Using the DELTA_HASH from the previous step, and the recovery-commitment, generate an instance of the Create Operation Suffix Data Object as follows: SUFFIX_DATA = { delta_hash: DELTA_HASH, recovery_commitment: RECOVERY_COMMITMENT } SUFFIX_DATA is of type SuffixDataModel Then stringify it and encode it with the data encoding scheme as ENCODED_SUFFIX_DATA . 8. Sidetree request 8.1 Generate the following object: SIDETREE_REQUEST = { suffix_data: ENCODED_SUFFIX_DATA, type: OperationType.Create, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as OPERATION_BUFFER 8.3 Send the OPERATION_BUFFER to the Sidetree's library CreateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The didUniqueSuffix is generated by decoding the ENCODED_SUFFIX_DATA as a buffer, then hashing it with the hash algorithm & hash protocol and then encoding it again with the data encoding scheme . The type of operation: type: OperationType.Create The data used to generate the unique DID suffix: suffixData: SuffixDataModel The encoded string of the suffix data: encodedSuffixData: string The Create Operation Delta Object: delta: DeltaModel | undefined The encoded string of the delta: encodedDelta: string | undefined 9. tyronZIL DID-create operation result The return value of a tyronZIL-js DID-create operation is an instance of the class DidCreate , which includes all the previously mentioned properties plus additional such as public, private keys, commitments and service endpoints.","title":"Create"},{"location":"operations/CRUD/did-create/#tyronzil-did-create-operation","text":"A tyronZIL DID-create operation is conformant with a Sidetree Create operation, and its goal is to generate a brand new tyronZIL Decentralized Identifier. Follow these steps:","title":"tyronZIL DID-create operation"},{"location":"operations/CRUD/did-create/#1-verification-methods","text":"tyronZIL supports 3 verification methods: 'publicKey', 'operation' and 'recovery'. 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[] 1.2 Under the property 'operation', assign to its value an Operation verification method object: operation: Operation 1.3 Under the property 'recovery', assign to its value a Recovery verification method object: recovery: Recovery","title":"1. Verification methods"},{"location":"operations/CRUD/did-create/#2-public-key-commitments","text":"2.1 For the public key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY )","title":"2. Public key commitments"},{"location":"operations/CRUD/did-create/#3-service-endpoints","text":"Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[]","title":"3. Service endpoints"},{"location":"operations/CRUD/did-create/#4-document-model","text":"Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service }","title":"4. Document model"},{"location":"operations/CRUD/did-create/#5-did-state-patch","text":"Put the previously generated document inside of a DID state patch . For the DID-create operation, the patch action is 'replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction","title":"5. DID state patch"},{"location":"operations/CRUD/did-create/#6-create-operation-delta-object","text":"6.1 Using the DID state patch and the update-commitment, generate an instance of the Create Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol and then encode it again as DELTA_HASH","title":"6. Create Operation Delta Object"},{"location":"operations/CRUD/did-create/#7-create-operation-suffix-data-object","text":"7.1 Using the DELTA_HASH from the previous step, and the recovery-commitment, generate an instance of the Create Operation Suffix Data Object as follows: SUFFIX_DATA = { delta_hash: DELTA_HASH, recovery_commitment: RECOVERY_COMMITMENT } SUFFIX_DATA is of type SuffixDataModel Then stringify it and encode it with the data encoding scheme as ENCODED_SUFFIX_DATA .","title":"7. Create Operation Suffix Data Object"},{"location":"operations/CRUD/did-create/#8-sidetree-request","text":"8.1 Generate the following object: SIDETREE_REQUEST = { suffix_data: ENCODED_SUFFIX_DATA, type: OperationType.Create, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as OPERATION_BUFFER 8.3 Send the OPERATION_BUFFER to the Sidetree's library CreateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The didUniqueSuffix is generated by decoding the ENCODED_SUFFIX_DATA as a buffer, then hashing it with the hash algorithm & hash protocol and then encoding it again with the data encoding scheme . The type of operation: type: OperationType.Create The data used to generate the unique DID suffix: suffixData: SuffixDataModel The encoded string of the suffix data: encodedSuffixData: string The Create Operation Delta Object: delta: DeltaModel | undefined The encoded string of the delta: encodedDelta: string | undefined","title":"8. Sidetree request"},{"location":"operations/CRUD/did-create/#9-tyronzil-did-create-operation-result","text":"The return value of a tyronZIL-js DID-create operation is an instance of the class DidCreate , which includes all the previously mentioned properties plus additional such as public, private keys, commitments and service endpoints.","title":"9. tyronZIL DID-create operation result"},{"location":"operations/CRUD/did-deactivate/","text":"tyronZIL DID-deactivate operation coming soon","title":"Deactivate"},{"location":"operations/CRUD/did-deactivate/#tyronzil-did-deactivate-operation","text":"coming soon","title":"tyronZIL DID-deactivate operation"},{"location":"operations/CRUD/did-recover/","text":"tyronZIL DID-resolve operation coming soon","title":"Recover"},{"location":"operations/CRUD/did-recover/#tyronzil-did-resolve-operation","text":"coming soon","title":"tyronZIL DID-resolve operation"},{"location":"operations/CRUD/did-resolve/","text":"tyronZIL DID-resolve operation Resolution It corresponds to the READ operation of a DID. The DID resolution function resolves a DID into its DID-document by performing the process called DID resolution. A DID Resolver is the software component that executes the DID resolution function. It takes a DID (and metadata) as input and produces a conforming DID-document (and metadata) as output. DID URL dereferencing DID URL dereferencing is the process that returns the particular resource specified by the DID URL. It can use the DID resolution function to fetch the DID-document and then it performs additional processing on the DID-document to return the dereferenced resource that was requested. The software component is called DID URL Dereferencer, and it takes as input a DID URL, a DID-document and a set of dereferencing options and returns the specific resource. The dereferencing options control how the resource is dereferenced. DID resolution variables Input variables did : A conformant DID as a single string. This is the DID to resolve. This input is REQUIRED. did-resolution-input-metadata : A metadata structure consisting of input options to the resolve function in addition to the DID itself. This input is REQUIRED, but the structure MAY be empty. The options control how the DID is resolved. Output variables did-resolution-metadata : A metadata structure consisting of values relating to the results of the DID resolution process. This structure is REQUIRED and MUST NOT be empty. This metadata typically changes between invocations of the resolve function as it represents data about the resolution process itself. did-document-stream : This MUST be a byte stream of the resolved DID-document in one of the conformant representations. The byte stream MAY then be parsed by the caller of the resolve function into a DID-document abstract data model, which can in turn be validated and processed. If the resolution is unsuccessful, this value MUST be an empty stream. did-document-metadata : This MUST be a metadata structure. This structure contains metadata about the DID-document contained in the did-document-stream. This metadata typically does not change between invocations of the resolve function unless the DID-document changes, as it represents data about the DID-document. If the resolution is unsuccessful, this output MUST be an empty metadata structure.","title":"Resolve"},{"location":"operations/CRUD/did-resolve/#tyronzil-did-resolve-operation","text":"","title":"tyronZIL DID-resolve operation"},{"location":"operations/CRUD/did-resolve/#resolution","text":"It corresponds to the READ operation of a DID. The DID resolution function resolves a DID into its DID-document by performing the process called DID resolution. A DID Resolver is the software component that executes the DID resolution function. It takes a DID (and metadata) as input and produces a conforming DID-document (and metadata) as output.","title":"Resolution"},{"location":"operations/CRUD/did-resolve/#did-url-dereferencing","text":"DID URL dereferencing is the process that returns the particular resource specified by the DID URL. It can use the DID resolution function to fetch the DID-document and then it performs additional processing on the DID-document to return the dereferenced resource that was requested. The software component is called DID URL Dereferencer, and it takes as input a DID URL, a DID-document and a set of dereferencing options and returns the specific resource. The dereferencing options control how the resource is dereferenced.","title":"DID URL dereferencing"},{"location":"operations/CRUD/did-resolve/#did-resolution-variables","text":"","title":"DID resolution variables"},{"location":"operations/CRUD/did-resolve/#input-variables","text":"did : A conformant DID as a single string. This is the DID to resolve. This input is REQUIRED. did-resolution-input-metadata : A metadata structure consisting of input options to the resolve function in addition to the DID itself. This input is REQUIRED, but the structure MAY be empty. The options control how the DID is resolved.","title":"Input variables"},{"location":"operations/CRUD/did-resolve/#output-variables","text":"did-resolution-metadata : A metadata structure consisting of values relating to the results of the DID resolution process. This structure is REQUIRED and MUST NOT be empty. This metadata typically changes between invocations of the resolve function as it represents data about the resolution process itself. did-document-stream : This MUST be a byte stream of the resolved DID-document in one of the conformant representations. The byte stream MAY then be parsed by the caller of the resolve function into a DID-document abstract data model, which can in turn be validated and processed. If the resolution is unsuccessful, this value MUST be an empty stream. did-document-metadata : This MUST be a metadata structure. This structure contains metadata about the DID-document contained in the did-document-stream. This metadata typically does not change between invocations of the resolve function unless the DID-document changes, as it represents data about the DID-document. If the resolution is unsuccessful, this output MUST be an empty metadata structure.","title":"Output variables"},{"location":"operations/CRUD/did-update/","text":"tyronZIL DID-update operation coming soon","title":"Update"},{"location":"operations/CRUD/did-update/#tyronzil-did-update-operation","text":"coming soon","title":"tyronZIL DID-update operation"},{"location":"scheme/did-scheme/","text":"DID-scheme A DID-scheme is the formal syntax of a Decentralized Identifier. Generic W3C DID-scheme It is a URI scheme conformant with RFC3986, Uniform Resource Identifier (URI): Generic Syntax . The following is the ABNF definition with ALPHA and DIGIT: Using the syntax in RFC5234, Augmented BNF for Syntax Specifications: ABNF . Generic rule names not defined there, are defined in RFC3986 did = \"did:\" method-name \":\" method-specific-id method-name = 1*method-char method-char = %x61-7A / DIGIT method-specific-id = *( *idchar \":\" ) 1*idchar idchar = ALPHA / DIGIT / \".\" / \"-\" / \"_\" Both the scheme identifier (did) and the method name MUST be an ASCII lowercase string . tyronZIL DID-scheme The tyronZIL DID method defines its method-name as \"tyron\" and the method-specific-id syntax as hierarchically partitioned: method-name = \"tyron\" method-specific-id = blockchain-namespace \":\" network-namespace \":\" did-suffix blockchain-namespace = \"zil:\" network-namespace = 1*idchar did-suffix = 1*idchar The network-namespace MUST be one of the following variants: enum NetworkNamespace { Mainnet = 'main:', Testnet = 'test:', } Example of a tyronZIL DID : did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g DID-suffix The did-suffix MUST be globally unique and generated as specified in the tyronZIL DID-create operation . Normalization The DID-scheme name (did) MUST be lowercase. The DID method-name (tyron) MUST be lowercase. TyronZIL's specific-id MUST follow the rules stated above. Persistence A tyronZIL DID is bound exclusively and permanently to its one and only subject , even after deactivation. Implementation The tyronZIL-js DID-scheme corresponds to the class TyronZILScheme , which has the following properties: schemeIdentifier = 'did:' methodName = 'tyron:' blockchain = 'zil:' network = NetworkNamespace didUniqueSuffix: string did_tyronZIL: string did_tyronZIL is the fully expressed tyronZIL DID","title":"DID-scheme"},{"location":"scheme/did-scheme/#did-scheme","text":"A DID-scheme is the formal syntax of a Decentralized Identifier.","title":"DID-scheme"},{"location":"scheme/did-scheme/#generic-w3c-did-scheme","text":"It is a URI scheme conformant with RFC3986, Uniform Resource Identifier (URI): Generic Syntax . The following is the ABNF definition with ALPHA and DIGIT: Using the syntax in RFC5234, Augmented BNF for Syntax Specifications: ABNF . Generic rule names not defined there, are defined in RFC3986 did = \"did:\" method-name \":\" method-specific-id method-name = 1*method-char method-char = %x61-7A / DIGIT method-specific-id = *( *idchar \":\" ) 1*idchar idchar = ALPHA / DIGIT / \".\" / \"-\" / \"_\" Both the scheme identifier (did) and the method name MUST be an ASCII lowercase string .","title":"Generic W3C DID-scheme"},{"location":"scheme/did-scheme/#tyronzil-did-scheme","text":"The tyronZIL DID method defines its method-name as \"tyron\" and the method-specific-id syntax as hierarchically partitioned: method-name = \"tyron\" method-specific-id = blockchain-namespace \":\" network-namespace \":\" did-suffix blockchain-namespace = \"zil:\" network-namespace = 1*idchar did-suffix = 1*idchar The network-namespace MUST be one of the following variants: enum NetworkNamespace { Mainnet = 'main:', Testnet = 'test:', } Example of a tyronZIL DID : did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g","title":"tyronZIL DID-scheme"},{"location":"scheme/did-scheme/#did-suffix","text":"The did-suffix MUST be globally unique and generated as specified in the tyronZIL DID-create operation .","title":"DID-suffix"},{"location":"scheme/did-scheme/#normalization","text":"The DID-scheme name (did) MUST be lowercase. The DID method-name (tyron) MUST be lowercase. TyronZIL's specific-id MUST follow the rules stated above.","title":"Normalization"},{"location":"scheme/did-scheme/#persistence","text":"A tyronZIL DID is bound exclusively and permanently to its one and only subject , even after deactivation.","title":"Persistence"},{"location":"scheme/did-scheme/#implementation","text":"The tyronZIL-js DID-scheme corresponds to the class TyronZILScheme , which has the following properties: schemeIdentifier = 'did:' methodName = 'tyron:' blockchain = 'zil:' network = NetworkNamespace didUniqueSuffix: string did_tyronZIL: string did_tyronZIL is the fully expressed tyronZIL DID","title":"Implementation"},{"location":"scheme/did-url-syntax/","text":"tyronZIL DID URL syntax The following is the ABNF definition using the syntax in RFC5324 : The path-abempty and fragment components are identical to the ABNF rules defined in RFC3986 The did-query component is derived from the query ABNF rule did-url = did path-abempty [ \"?\" did-query ] [ \"#\" fragment ] did-query = param *( \"&\" param ) param = param-name \"=\" param-value param-name = 1*pchar param-value = *pchar Path To be used to address resources available through a service endpoint. It MUST conform to the path-abempty ABFN rule in RFC3986 . Query The W3C did-query component derives from the query ABFN rule. It MUST be used with DID parameters as follows. DID URL parameters These parameters are part of the query component of the DID URL to specify what resource is requested. W3C DID parameter-names: hl : A resource hash of the DID-document to add integrity protection. service : Identifies a service from the DID-document by service ID. did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?service=agentId1 version-id : Identifies a specific version of the DID-document to be resolved. version-time : Identifies a specific version timestamp of the DID-document to be resolved (the doc that was valid at that particular time). did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?version-time=2020-09-07T17:00:00Z Additional parameters MUST be prefixed by the method name 'tyron', e.g.: 'tyron-dns'. TyronZIL method-specific parameter names MAY be used by other DID methods. Method-specific parameter names MAY be combined with generic parameter names in any order. Method-specific parameter namespaces MAY include colons to be partitioned hierarchically. Fragment A W3C DID fragment is used as a method-independent reference into the DID-document to identify a component of the document by ID, e.g. a specific public key or service endpoint. It MUST conform to the generic URI fragment syntax in RFC3986 .","title":"DID URL syntax"},{"location":"scheme/did-url-syntax/#tyronzil-did-url-syntax","text":"The following is the ABNF definition using the syntax in RFC5324 : The path-abempty and fragment components are identical to the ABNF rules defined in RFC3986 The did-query component is derived from the query ABNF rule did-url = did path-abempty [ \"?\" did-query ] [ \"#\" fragment ] did-query = param *( \"&\" param ) param = param-name \"=\" param-value param-name = 1*pchar param-value = *pchar","title":"tyronZIL DID URL syntax"},{"location":"scheme/did-url-syntax/#path","text":"To be used to address resources available through a service endpoint. It MUST conform to the path-abempty ABFN rule in RFC3986 .","title":"Path"},{"location":"scheme/did-url-syntax/#query","text":"The W3C did-query component derives from the query ABFN rule. It MUST be used with DID parameters as follows.","title":"Query"},{"location":"scheme/did-url-syntax/#did-url-parameters","text":"These parameters are part of the query component of the DID URL to specify what resource is requested. W3C DID parameter-names: hl : A resource hash of the DID-document to add integrity protection. service : Identifies a service from the DID-document by service ID. did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?service=agentId1 version-id : Identifies a specific version of the DID-document to be resolved. version-time : Identifies a specific version timestamp of the DID-document to be resolved (the doc that was valid at that particular time). did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?version-time=2020-09-07T17:00:00Z Additional parameters MUST be prefixed by the method name 'tyron', e.g.: 'tyron-dns'. TyronZIL method-specific parameter names MAY be used by other DID methods. Method-specific parameter names MAY be combined with generic parameter names in any order. Method-specific parameter namespaces MAY include colons to be partitioned hierarchically.","title":"DID URL parameters"},{"location":"scheme/did-url-syntax/#fragment","text":"A W3C DID fragment is used as a method-independent reference into the DID-document to identify a component of the document by ID, e.g. a specific public key or service endpoint. It MUST conform to the generic URI fragment syntax in RFC3986 .","title":"Fragment"}]}