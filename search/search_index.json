{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tyronZIL DID-Method specification v0.4 A W3C DID-Method for the Zilliqa blockchain platform Developed by Julio Cabrapan Duarte Funded by ZILHive Conformance The tyronZIL DID-Method is conformant with the World Wide Web Consortium (W3C) Decentralized Identifiers (DIDs) v1.0 specification. Tyron implements Sidetree delta-based DID operations and saves the state in a Scilla smart-contract that is owned by the user. The user is both the DID-Subject and DID-Controller of their Decentralized Identifier. Problem summary Identities on the internet remain centralized, mainly by identity providers such as Facebook, Google and PayPal. Thus, when people shop online and login with these accounts, they don't have enough control nor understanding of how their data is used and shared with third parties. Self-Sovereign Identity (SSI) allows people to manage their digital identities, proving who they are without a middleman, by anchoring Decentralized Identifiers (DIDs) on blockchain platforms/distributed-ledgers as a shared root of trust. However, most DLTs still can't provide decentralized identity at scale. By implementing Decentralized Identifiers powered by Sidetree & Scilla, tyronZIL aims to solve this issue to enable user-controlled digital identities. Index W3C DIDs Sidetree protocol and default parameters DID-Document Scheme: DID-Scheme DID-URL syntax Operations: Introduction DID CRUD: Create Resolve Recover Update Deactivate Implementation: tyronZIL-js : The open-source reference implementation for Node.js, written in TypeScript Sidetree models Privacy Considerations","title":"Home"},{"location":"#tyronzil-did-method-specification-v04","text":"A W3C DID-Method for the Zilliqa blockchain platform Developed by Julio Cabrapan Duarte Funded by ZILHive","title":"tyronZIL DID-Method specification v0.4"},{"location":"#conformance","text":"The tyronZIL DID-Method is conformant with the World Wide Web Consortium (W3C) Decentralized Identifiers (DIDs) v1.0 specification. Tyron implements Sidetree delta-based DID operations and saves the state in a Scilla smart-contract that is owned by the user. The user is both the DID-Subject and DID-Controller of their Decentralized Identifier.","title":"Conformance"},{"location":"#problem-summary","text":"Identities on the internet remain centralized, mainly by identity providers such as Facebook, Google and PayPal. Thus, when people shop online and login with these accounts, they don't have enough control nor understanding of how their data is used and shared with third parties. Self-Sovereign Identity (SSI) allows people to manage their digital identities, proving who they are without a middleman, by anchoring Decentralized Identifiers (DIDs) on blockchain platforms/distributed-ledgers as a shared root of trust. However, most DLTs still can't provide decentralized identity at scale. By implementing Decentralized Identifiers powered by Sidetree & Scilla, tyronZIL aims to solve this issue to enable user-controlled digital identities.","title":"Problem summary"},{"location":"#index","text":"W3C DIDs Sidetree protocol and default parameters DID-Document Scheme: DID-Scheme DID-URL syntax Operations: Introduction DID CRUD: Create Resolve Recover Update Deactivate Implementation: tyronZIL-js : The open-source reference implementation for Node.js, written in TypeScript Sidetree models Privacy Considerations","title":"Index"},{"location":"W3C-dids/","text":"W3C DIDs The tyronZIL DID-Method refers to the following terms specified in W3C Decentralized Identifiers (DIDs) v1.0 : DID-Method A DID-Method is the specification for the precise scheme of a DID, and it also specifies the methods creating, resolving, updating and deactivating such a DID and its DID-Document, using a specific type of verifiable data registry, in tyronZIL's case Zilliqa. Learn about the precise tyronZIL: - DID-Scheme - DID operations Decentralized Identifier (DID) A DID is a globally unique Uniform Resource Identifier (URI) that associates a DID-Subject with a DID-Document. Given the decentralized nature of Zilliqa, a tyronZIL DID has its existence guaranteed without depending on a central authority. A DID consists of three parts: The scheme identifier: \"did\" The DID-Method identifier The DID-Method-specific identifier, which must be unique DID-URL A DID-URL identifies a particular resource to be located, e.g. a specific part of the DID-Document. It extends the syntax of a basic DID to incorporate other standard URI components: Path: The portion of a DID-URL that begins with and includes the first forward slash character, \"/\" Query: The portion of a DID-URL that follows the first question mark character, \"?\" Fragment: The portion of a DID-URL that follows the first hash sign character \"#\" DID-Subject The DID-Subject is the entity identified by the DID and described by the DID-Document - the user of the Decentralized Identifier. DID-Controller The DID-Controller is the entity that has the capability - as defined by the DID-Method - to make changes to a DID-Document. For the current version of the tyronZIL DID-Method, the user is the sole Controller of their DID. DID-Document A DID is resolvable to a DID-Document, which contains data associated with the DID, such as cryptographic material, verification methods and service endpoints relevant to interactions with the DID-Subject. The DID itself is the value of the 'id' property. tyronZIL DID-Document Verification method A verification method is a set of parameters used to independently verify a proof according to the particular DID-Method, e.g. a public key. Verification relationship It expresses the relationship between the DID-Subject and a verification method, e.g. authentication. All verification methods must be associated with a particular verification relationship. Producer A producer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by generating conforming DIDs or conforming DID-Documents. A producer that is conformant with the specification MUST NOT produce non-conforming DIDs or DID-Documents. Producers MUST indicate which representation of a document corresponds via a 'contentType' in the document's resolution-metadata. Consumer A consumer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by consuming conforming DIDs or conforming DID-Documents. A consumer that is conformant with the specification MUST produce errors when consuming non-conforming DIDs or DID-Documents. Consumers MUST determine which is the representation of the DID-Document via the 'contentType' DID resolver metadata field.","title":"W3C DIDs"},{"location":"W3C-dids/#w3c-dids","text":"The tyronZIL DID-Method refers to the following terms specified in W3C Decentralized Identifiers (DIDs) v1.0 :","title":"W3C DIDs"},{"location":"W3C-dids/#did-method","text":"A DID-Method is the specification for the precise scheme of a DID, and it also specifies the methods creating, resolving, updating and deactivating such a DID and its DID-Document, using a specific type of verifiable data registry, in tyronZIL's case Zilliqa. Learn about the precise tyronZIL: - DID-Scheme - DID operations","title":"DID-Method"},{"location":"W3C-dids/#decentralized-identifier-did","text":"A DID is a globally unique Uniform Resource Identifier (URI) that associates a DID-Subject with a DID-Document. Given the decentralized nature of Zilliqa, a tyronZIL DID has its existence guaranteed without depending on a central authority. A DID consists of three parts: The scheme identifier: \"did\" The DID-Method identifier The DID-Method-specific identifier, which must be unique","title":"Decentralized Identifier (DID)"},{"location":"W3C-dids/#did-url","text":"A DID-URL identifies a particular resource to be located, e.g. a specific part of the DID-Document. It extends the syntax of a basic DID to incorporate other standard URI components: Path: The portion of a DID-URL that begins with and includes the first forward slash character, \"/\" Query: The portion of a DID-URL that follows the first question mark character, \"?\" Fragment: The portion of a DID-URL that follows the first hash sign character \"#\"","title":"DID-URL"},{"location":"W3C-dids/#did-subject","text":"The DID-Subject is the entity identified by the DID and described by the DID-Document - the user of the Decentralized Identifier.","title":"DID-Subject"},{"location":"W3C-dids/#did-controller","text":"The DID-Controller is the entity that has the capability - as defined by the DID-Method - to make changes to a DID-Document. For the current version of the tyronZIL DID-Method, the user is the sole Controller of their DID.","title":"DID-Controller"},{"location":"W3C-dids/#did-document","text":"A DID is resolvable to a DID-Document, which contains data associated with the DID, such as cryptographic material, verification methods and service endpoints relevant to interactions with the DID-Subject. The DID itself is the value of the 'id' property. tyronZIL DID-Document","title":"DID-Document"},{"location":"W3C-dids/#verification-method","text":"A verification method is a set of parameters used to independently verify a proof according to the particular DID-Method, e.g. a public key.","title":"Verification method"},{"location":"W3C-dids/#verification-relationship","text":"It expresses the relationship between the DID-Subject and a verification method, e.g. authentication. All verification methods must be associated with a particular verification relationship.","title":"Verification relationship"},{"location":"W3C-dids/#producer","text":"A producer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by generating conforming DIDs or conforming DID-Documents. A producer that is conformant with the specification MUST NOT produce non-conforming DIDs or DID-Documents. Producers MUST indicate which representation of a document corresponds via a 'contentType' in the document's resolution-metadata.","title":"Producer"},{"location":"W3C-dids/#consumer","text":"A consumer is any algorithm realized as software/hardware that conforms to the W3C DIDs specification by consuming conforming DIDs or conforming DID-Documents. A consumer that is conformant with the specification MUST produce errors when consuming non-conforming DIDs or DID-Documents. Consumers MUST determine which is the representation of the DID-Document via the 'contentType' DID resolver metadata field.","title":"Consumer"},{"location":"did-document/","text":"tyronZIL DID-Document For an introduction, read this A DID-Document is a graph-based data structure, a collection of property-value pairs, serialized according to a particular syntax. TyronZIL's serialization format is JSON: It defines an unambiguous encoding and decoding of all properties and their associated values It MUST be a single JSON object conforming to RFC8259, The JavaScript Object Notation (JSON) Data Interchange Format The names of the members of the JSON object MUST correspond to the core property names of the DID-Document Property values MUST be: - Numbers for number values representable as IEEE754 - Literal values for boolean ('false', 'true') and empty values ('null') - Arrays for sequence values and unordered sets of values - Objects for sets of properties - Strings for all other values. Consumers MAY further parse these strings into more specific data types such as URIs and date stamps The 'contentType' property in the resolver's metadata MUST be application/did+json : - Which is the associated IANA-registered MIME type, with its corresponding rules to process the fragment - Producers MUST write this type in the document's metadata, and consumers MUST validate it as well Consumers MUST ignore unknown object member names as unknown properties Core properties id The id value MUST be a single valid tyronZIL DID itself, e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\" } All W3C DID-Documents MUST include the \"id\" property, which denotes the DID-Subject . publicKey The publicKey property is the main verification method . The publicKey value MUST be an array of objects of type VerificationMethodModel , e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\", \"publicKey\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#keyID\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ksEhVIcb7JGKp_zNL0NJJxFBNzGgERzSQrZjEfkvPJc\", \"y\": \"J3h3PgSqdUXkDt1CIZHbWmKvhlD1bedJX6VE3u1o7bE\", \"kid\": \"G0cATxTiiCC4Xt3NnANRCrfBOexYpQhB0Sy616E5LTE\" } }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#anotherKeyID\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"publicKeyJwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ynsq5eFLNaV-rIJxpT_QMBZ3dXv2kQwHzw7VZKjU8fs\", \"y\": \"q_Nw9PhUkWpt0mV5C62qydBokP09p8gkSKy9nFNTq60\", \"kid\": \"ofnZh1sI0we7eYfiDfIxcqK10NezOLvcQfCEBacbzOQ\" } } ] } All verification methods MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID-URL. There MUST NOT be multiple verification method objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be exactly one verification method type. The default type is currently EcdsaSecp256k1VerificationKey2019 \"controller\": Its value MUST be a valid tyronZIL DID representing the entity that controls the corresponding private key \"publicKeyJwk\": The cryptographic key itself expressed as a IETF RFC 7517 compliant JSON Web Key (JWK) representation for the KEY_ALGORITHM Before processing them into the DID-Document, each verification method has a property called purpose . It states the functionality of the key, its verification relationship . For public keys, the purpose value MUST be an array of PublicKeyPurpose variants . authentication At least one public key MUST have its purpose as PublicKeyPurpose.Auth = 'auth' . The authentication value MUST be an array of verification methods. Each verification method MAY be embedded or referenced, e.g.: { \"authentication\": [ // referenced key: \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", // embedded key: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#authentication-key\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"W5-Wa5xk6rtIyC4b0cp3JAb8-Rmhc_CIRPt-JPexZWY\", \"y\": \"XD15geXy_UBRByhnI_fuAZhvWSsaYR0L92jTLr63xk8\", \"kid\": \"Juvzhd0beV-bR8Oq12JYt4wyYYZ8Zndrb9oM_WMxoF4\" } } ] } Service endpoints tyronZIL service endpoints are used to express ways of communicating with the DID subject , from privacy preserving messaging services to cryptocurrency addresses. The service value MUST be an array of objects of type ServiceEndpointModel , e.g.: { \"service\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#tyronZIL-website\", \"type\": \"method-specification\", \"endpoint\": \"https://tyronZIL.com\" }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#ZIL-address\", \"type\": \"cryptocurrency-address\", \"endpoint\": \"zil1egvj6ketfydy48uqzu8qphhj5w4xrkratv85ht\" } ] } All services MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID-URL with a length no more than fifty (50) ASCII encoded characters. There MUST NOT be multiple keys with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be a string with a length of no more than thirty (30) ASCII encoded characters \"endpoint\": Its value MUST be a valid URI string (including a scheme segment: i.e. http://, git://), with a length of no more than one hundred (100) ASCII encoded characters If any of the values exceed the specified lengths, the consumer MUST produce an error.","title":"DID-Document"},{"location":"did-document/#tyronzil-did-document","text":"For an introduction, read this A DID-Document is a graph-based data structure, a collection of property-value pairs, serialized according to a particular syntax. TyronZIL's serialization format is JSON: It defines an unambiguous encoding and decoding of all properties and their associated values It MUST be a single JSON object conforming to RFC8259, The JavaScript Object Notation (JSON) Data Interchange Format The names of the members of the JSON object MUST correspond to the core property names of the DID-Document Property values MUST be: - Numbers for number values representable as IEEE754 - Literal values for boolean ('false', 'true') and empty values ('null') - Arrays for sequence values and unordered sets of values - Objects for sets of properties - Strings for all other values. Consumers MAY further parse these strings into more specific data types such as URIs and date stamps The 'contentType' property in the resolver's metadata MUST be application/did+json : - Which is the associated IANA-registered MIME type, with its corresponding rules to process the fragment - Producers MUST write this type in the document's metadata, and consumers MUST validate it as well Consumers MUST ignore unknown object member names as unknown properties","title":"tyronZIL DID-Document"},{"location":"did-document/#core-properties","text":"","title":"Core properties"},{"location":"did-document/#id","text":"The id value MUST be a single valid tyronZIL DID itself, e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\" } All W3C DID-Documents MUST include the \"id\" property, which denotes the DID-Subject .","title":"id"},{"location":"did-document/#publickey","text":"The publicKey property is the main verification method . The publicKey value MUST be an array of objects of type VerificationMethodModel , e.g.: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w\", \"publicKey\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#keyID\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ksEhVIcb7JGKp_zNL0NJJxFBNzGgERzSQrZjEfkvPJc\", \"y\": \"J3h3PgSqdUXkDt1CIZHbWmKvhlD1bedJX6VE3u1o7bE\", \"kid\": \"G0cATxTiiCC4Xt3NnANRCrfBOexYpQhB0Sy616E5LTE\" } }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#anotherKeyID\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"publicKeyJwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"ynsq5eFLNaV-rIJxpT_QMBZ3dXv2kQwHzw7VZKjU8fs\", \"y\": \"q_Nw9PhUkWpt0mV5C62qydBokP09p8gkSKy9nFNTq60\", \"kid\": \"ofnZh1sI0we7eYfiDfIxcqK10NezOLvcQfCEBacbzOQ\" } } ] } All verification methods MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID-URL. There MUST NOT be multiple verification method objects with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be exactly one verification method type. The default type is currently EcdsaSecp256k1VerificationKey2019 \"controller\": Its value MUST be a valid tyronZIL DID representing the entity that controls the corresponding private key \"publicKeyJwk\": The cryptographic key itself expressed as a IETF RFC 7517 compliant JSON Web Key (JWK) representation for the KEY_ALGORITHM Before processing them into the DID-Document, each verification method has a property called purpose . It states the functionality of the key, its verification relationship . For public keys, the purpose value MUST be an array of PublicKeyPurpose variants .","title":"publicKey"},{"location":"did-document/#authentication","text":"At least one public key MUST have its purpose as PublicKeyPurpose.Auth = 'auth' . The authentication value MUST be an array of verification methods. Each verification method MAY be embedded or referenced, e.g.: { \"authentication\": [ // referenced key: \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#primarySigningKey\", // embedded key: { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#authentication-key\", \"type\": \"EcdsaSecp256k1VerificationKey2019\", \"jwk\": { \"kty\": \"EC\", \"crv\": \"secp256k1\", \"x\": \"W5-Wa5xk6rtIyC4b0cp3JAb8-Rmhc_CIRPt-JPexZWY\", \"y\": \"XD15geXy_UBRByhnI_fuAZhvWSsaYR0L92jTLr63xk8\", \"kid\": \"Juvzhd0beV-bR8Oq12JYt4wyYYZ8Zndrb9oM_WMxoF4\" } } ] }","title":"authentication"},{"location":"did-document/#service-endpoints","text":"tyronZIL service endpoints are used to express ways of communicating with the DID subject , from privacy preserving messaging services to cryptocurrency addresses. The service value MUST be an array of objects of type ServiceEndpointModel , e.g.: { \"service\": [ { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#tyronZIL-website\", \"type\": \"method-specification\", \"endpoint\": \"https://tyronZIL.com\" }, { \"id\": \"did:tyron:zil:test:EiBtH2NHC5nOdcp6iMTjq2rvuQj5gbvnSwgqYIMMXne38w#ZIL-address\", \"type\": \"cryptocurrency-address\", \"endpoint\": \"zil1egvj6ketfydy48uqzu8qphhj5w4xrkratv85ht\" } ] } All services MUST have the following properties: \"id\": Its value MUST be a unique tyronZIL DID-URL with a length no more than fifty (50) ASCII encoded characters. There MUST NOT be multiple keys with the same id-value - otherwise the consumer MUST produce an error \"type\": Its value MUST be a string with a length of no more than thirty (30) ASCII encoded characters \"endpoint\": Its value MUST be a valid URI string (including a scheme segment: i.e. http://, git://), with a length of no more than one hundred (100) ASCII encoded characters If any of the values exceed the specified lengths, the consumer MUST produce an error.","title":"Service endpoints"},{"location":"sidetree/","text":"Sidetree protocol Here you can learn about the Sidetree protocol terminology and the default parameters used by tyronZIL. Sidetree DID operation A Sidetree DID operation is a set of delta-based modifications that change the state of a DID-Document when applied. Sidetree transaction number The Sidetreee transaction number is a monotonically increasing number. Its order is deterministic and assigned to every transaction according to its position in the ledger time. In tyronZIL's implementation, each DID has a corresponding Tyron-Smart-Contract that keeps track of the DID-State and assigns a Sidetree transaction number to every consecutive transaction modifying the DID-State. Ledger time The ledger time is the blockchain clock variable, used as a deterministic chronological reference. DID-Suffix A DID-Suffix is the unique identifier string in a Decentralized Identifier, the last part of the DID after the final colon. Long-Form DID-URI This type of DID-URL has the necessary information to immediately use a DID without anchoring it to the underlying ledger (therefore, the DID is unpropagated/unpublished). Format: DID?-sidetree-initial-state=<create-operation-suffix-data-object>.<create-operation-delta-object> More info here Hash algorithm The HASH_ALGORITH is the algorithm to generate hashes of protocol-related values. The default parameter is SHA256. Hash protocol The HASH_PROTOCOL is the protocol to generate hash representations using the HASH_ALGORITHM. The default parameter is Multihash : a protocol for differentiating outputs from various cryptographic hash functions, addressing size and encoding considerations. Data encoding scheme The DATA_ENCODING_SCHEME is the encoding for various data structures such as JSON and hashes, which MUST have its output in ASCII format. The default parameter is Base64URL. Key algorithm The KEY_ALGORITHM is the asymmetric public key algorithm to sign DID operations, which MUST be a valid JWK \"crv\". The default parameter is secp256k1. Operation key pair Generates a cryptographic key pair to operate with, using the KEY_ALGORITHM. It returns the public key as a PublicKeyModel and the private key as a secp256k1 key of type JwkEs256k . Public key commitment It is the resulting commitment obtained by applying the defined commitment scheme to a public key. Update-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of an update key pair. Recovery-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of a recovery key pair. Commitment scheme A cryptographic primitive that commits to a chosen value, known as the commit value resulting in the generation of a commitment. Then, that commitment written in the DID-Resolution-Result acts as a proof-of-commitment, without revealing the secret. The possessor of the corresponding private key can later produce the commit value, proving its validity against the original commitment. Public key commitment scheme Commitment scheme steps to generate a public key commitment from a public key: Encode the public key into the form of a valid JWK Canonicalize the JWK encoded public key using the JSON Canonicalization Scheme Apply the defined HASH_ALGORITHM to the canonicalized public key to produce the public key commitment Implementers MUST NOT re-use public keys across different commitment invocations. Signature algorithm The SIGNATURE_ALGORITHM is the asymmetric public key signature algorithm, which MUST be a valid JWS \"alg\". The default parameter is ES256K. Commitment hash The COMMITMENT_HASH is a cryptographically random hash of a value to be revealed in the next operation. The default parameter is 32 bytes. DID-State patch A DID-State patch is the Sidetree format to describe the mutations of the DID's metadata state. Its data structure corresponds with the Patch model , which MUST include a Patch action and the document to be patched. Sidetree verification relationships As defined by the W3C verification relationship , the Sidetree protocol requires the following verification relationships: enum SidetreeVerificationRelationship { Operation = 'operation', Recovery = 'recovery' } Operation: This verification relationship corresponds to a verification method of type update key, the key used to create the update-commitment , required by the DID-Update operation . Recovery: This verification relationship corresponds to a verification method of type recovery key, the key used to create the recovery-commitment , required by the operations DID-Recover and DID-Deactivate .","title":"Sidetree protocol"},{"location":"sidetree/#sidetree-protocol","text":"Here you can learn about the Sidetree protocol terminology and the default parameters used by tyronZIL.","title":"Sidetree protocol"},{"location":"sidetree/#sidetree-did-operation","text":"A Sidetree DID operation is a set of delta-based modifications that change the state of a DID-Document when applied.","title":"Sidetree DID operation"},{"location":"sidetree/#sidetree-transaction-number","text":"The Sidetreee transaction number is a monotonically increasing number. Its order is deterministic and assigned to every transaction according to its position in the ledger time. In tyronZIL's implementation, each DID has a corresponding Tyron-Smart-Contract that keeps track of the DID-State and assigns a Sidetree transaction number to every consecutive transaction modifying the DID-State.","title":"Sidetree transaction number"},{"location":"sidetree/#ledger-time","text":"The ledger time is the blockchain clock variable, used as a deterministic chronological reference.","title":"Ledger time"},{"location":"sidetree/#did-suffix","text":"A DID-Suffix is the unique identifier string in a Decentralized Identifier, the last part of the DID after the final colon.","title":"DID-Suffix"},{"location":"sidetree/#long-form-did-uri","text":"This type of DID-URL has the necessary information to immediately use a DID without anchoring it to the underlying ledger (therefore, the DID is unpropagated/unpublished). Format: DID?-sidetree-initial-state=<create-operation-suffix-data-object>.<create-operation-delta-object> More info here","title":"Long-Form DID-URI"},{"location":"sidetree/#hash-algorithm","text":"The HASH_ALGORITH is the algorithm to generate hashes of protocol-related values. The default parameter is SHA256.","title":"Hash algorithm"},{"location":"sidetree/#hash-protocol","text":"The HASH_PROTOCOL is the protocol to generate hash representations using the HASH_ALGORITHM. The default parameter is Multihash : a protocol for differentiating outputs from various cryptographic hash functions, addressing size and encoding considerations.","title":"Hash protocol"},{"location":"sidetree/#data-encoding-scheme","text":"The DATA_ENCODING_SCHEME is the encoding for various data structures such as JSON and hashes, which MUST have its output in ASCII format. The default parameter is Base64URL.","title":"Data encoding scheme"},{"location":"sidetree/#key-algorithm","text":"The KEY_ALGORITHM is the asymmetric public key algorithm to sign DID operations, which MUST be a valid JWK \"crv\". The default parameter is secp256k1.","title":"Key algorithm"},{"location":"sidetree/#operation-key-pair","text":"Generates a cryptographic key pair to operate with, using the KEY_ALGORITHM. It returns the public key as a PublicKeyModel and the private key as a secp256k1 key of type JwkEs256k .","title":"Operation key pair"},{"location":"sidetree/#public-key-commitment","text":"It is the resulting commitment obtained by applying the defined commitment scheme to a public key. Update-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of an update key pair. Recovery-commitment : The resulting commitment obtained by applying the defined commitment scheme to the public key of a recovery key pair.","title":"Public key commitment"},{"location":"sidetree/#commitment-scheme","text":"A cryptographic primitive that commits to a chosen value, known as the commit value resulting in the generation of a commitment. Then, that commitment written in the DID-Resolution-Result acts as a proof-of-commitment, without revealing the secret. The possessor of the corresponding private key can later produce the commit value, proving its validity against the original commitment.","title":"Commitment scheme"},{"location":"sidetree/#public-key-commitment-scheme","text":"Commitment scheme steps to generate a public key commitment from a public key: Encode the public key into the form of a valid JWK Canonicalize the JWK encoded public key using the JSON Canonicalization Scheme Apply the defined HASH_ALGORITHM to the canonicalized public key to produce the public key commitment Implementers MUST NOT re-use public keys across different commitment invocations.","title":"Public key commitment scheme"},{"location":"sidetree/#signature-algorithm","text":"The SIGNATURE_ALGORITHM is the asymmetric public key signature algorithm, which MUST be a valid JWS \"alg\". The default parameter is ES256K.","title":"Signature algorithm"},{"location":"sidetree/#commitment-hash","text":"The COMMITMENT_HASH is a cryptographically random hash of a value to be revealed in the next operation. The default parameter is 32 bytes.","title":"Commitment hash"},{"location":"sidetree/#did-state-patch","text":"A DID-State patch is the Sidetree format to describe the mutations of the DID's metadata state. Its data structure corresponds with the Patch model , which MUST include a Patch action and the document to be patched.","title":"DID-State patch"},{"location":"sidetree/#sidetree-verification-relationships","text":"As defined by the W3C verification relationship , the Sidetree protocol requires the following verification relationships: enum SidetreeVerificationRelationship { Operation = 'operation', Recovery = 'recovery' } Operation: This verification relationship corresponds to a verification method of type update key, the key used to create the update-commitment , required by the DID-Update operation . Recovery: This verification relationship corresponds to a verification method of type recovery key, the key used to create the recovery-commitment , required by the operations DID-Recover and DID-Deactivate .","title":"Sidetree verification relationships"},{"location":"implementation/models/","text":"Sidetree models tyronZIL-js implements the following data structures from the Sidetree protocol: JwkEs256k Model to represent a secp256k1 key in a JWK format: interface JwkEs256k { kty: string; crv: string; x: string; y: string; kid?: string; d?: string; //Only used by the private key } Verification method model interface VerificationMethodModel { id: string; type: string; publicKeyJwk: JwkEs256k; } Public key model interface PublicKeyModel { id: string; type: string; jwk: JwkEs256k; purpose: PublicKeyPurpose[]; } The type defaults to 'EcdsaSecp256k1VerificationKey2019'. Public key purpose enum PublicKeyPurpose { General = 'general', Auth = 'auth', Agreement = 'agreement', Assertion = 'assertion', Delegation = 'delegation', Invocation = 'invocation' } The current version only supports 'General' and 'Auth' purposes. Service endpoint model interface ServiceEndpointModel { id: string; type: string; endpoint: string; } Document model interface DocumentModel { public_keys: PublicKeyModel[]; service_endpoints?: ServiceEndpointModel[]; } Patch model interface PatchModel { action: PatchAction; publicKeys?: PublicKeyModel[]; serviceEndpoints?: ServiceEndpointModel[]; ids?: string[]; document: DocumentModel; } Patch action enum PatchAction { Replace = 'replace', AddKeys = 'add-public-keys', RemoveKeys = 'remove-public-keys', AddServices = 'add-service-endpoints', RemoveServices = 'remove-service-endpoints', CustomAction = '-custom-action', } 'Replace' acts as a complete state reset that replaces a DID's current PKI metadata with the state provided - also used to create a new DID. Delta model interface DeltaModel { patches: PatchModel[]; update_commitment: string; } Suffix data model interface SuffixDataModel { /** Encoded representation of the Create Operation Delta Object */ delta_hash: string; recovery_commitment: string; } Signed data models Define the model for the JWS payload object required by the Update, Recover and Deactivate Operation Signed Data Object, respectively. Update interface UpdateSignedDataModel { // Encoded representation of the Update Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous update commitment value update_key: JwkEs256k; } Recover export interface RecoverSignedDataModel { // Encoded representation of the Recovery Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; // A new recovery commitment for the next recover operation recovery_commitment: string; } Deactivate export interface DeactivateSignedDataModel { // The unique suffix of the DID to deactivate did_suffix: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; }","title":"Implementation"},{"location":"implementation/models/#sidetree-models","text":"tyronZIL-js implements the following data structures from the Sidetree protocol:","title":"Sidetree models"},{"location":"implementation/models/#jwkes256k","text":"Model to represent a secp256k1 key in a JWK format: interface JwkEs256k { kty: string; crv: string; x: string; y: string; kid?: string; d?: string; //Only used by the private key }","title":"JwkEs256k"},{"location":"implementation/models/#verification-method-model","text":"interface VerificationMethodModel { id: string; type: string; publicKeyJwk: JwkEs256k; }","title":"Verification method model"},{"location":"implementation/models/#public-key-model","text":"interface PublicKeyModel { id: string; type: string; jwk: JwkEs256k; purpose: PublicKeyPurpose[]; } The type defaults to 'EcdsaSecp256k1VerificationKey2019'.","title":"Public key model"},{"location":"implementation/models/#public-key-purpose","text":"enum PublicKeyPurpose { General = 'general', Auth = 'auth', Agreement = 'agreement', Assertion = 'assertion', Delegation = 'delegation', Invocation = 'invocation' } The current version only supports 'General' and 'Auth' purposes.","title":"Public key purpose"},{"location":"implementation/models/#service-endpoint-model","text":"interface ServiceEndpointModel { id: string; type: string; endpoint: string; }","title":"Service endpoint model"},{"location":"implementation/models/#document-model","text":"interface DocumentModel { public_keys: PublicKeyModel[]; service_endpoints?: ServiceEndpointModel[]; }","title":"Document model"},{"location":"implementation/models/#patch-model","text":"interface PatchModel { action: PatchAction; publicKeys?: PublicKeyModel[]; serviceEndpoints?: ServiceEndpointModel[]; ids?: string[]; document: DocumentModel; }","title":"Patch model"},{"location":"implementation/models/#patch-action","text":"enum PatchAction { Replace = 'replace', AddKeys = 'add-public-keys', RemoveKeys = 'remove-public-keys', AddServices = 'add-service-endpoints', RemoveServices = 'remove-service-endpoints', CustomAction = '-custom-action', } 'Replace' acts as a complete state reset that replaces a DID's current PKI metadata with the state provided - also used to create a new DID.","title":"Patch action"},{"location":"implementation/models/#delta-model","text":"interface DeltaModel { patches: PatchModel[]; update_commitment: string; }","title":"Delta model"},{"location":"implementation/models/#suffix-data-model","text":"interface SuffixDataModel { /** Encoded representation of the Create Operation Delta Object */ delta_hash: string; recovery_commitment: string; }","title":"Suffix data model"},{"location":"implementation/models/#signed-data-models","text":"Define the model for the JWS payload object required by the Update, Recover and Deactivate Operation Signed Data Object, respectively.","title":"Signed data models"},{"location":"implementation/models/#update","text":"interface UpdateSignedDataModel { // Encoded representation of the Update Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous update commitment value update_key: JwkEs256k; }","title":"Update"},{"location":"implementation/models/#recover","text":"export interface RecoverSignedDataModel { // Encoded representation of the Recovery Operation Delta Object hash delta_hash: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; // A new recovery commitment for the next recover operation recovery_commitment: string; }","title":"Recover"},{"location":"implementation/models/#deactivate","text":"export interface DeactivateSignedDataModel { // The unique suffix of the DID to deactivate did_suffix: string; // The JCS canonicalized IETF RFC 7517 compliant JWK representation matching the previous recovery commitment value recovery_key: JwkEs256k; }","title":"Deactivate"},{"location":"implementation/smart-contracts/tyron/","text":"The tyron smart-contract Zilliqa powers smart-contracts written in the Scilla programming language. The tyron smart-contract gets deployed with the following immutable fields: tyron_init: the address of the TyronInit smart contract contract_owner: the address of the user who is the owner of the contract The user must call the ContractInit transition that sets the: operation_cost foundation_address client_commission The input parameter is the client address that will manage the DID operations. These parameters can only change through the ContractInit transition, which calls the Initialize transition of the TyronInit contract Upcoming development: give client the option of offering discounts To create a DID, the Sidetree protocol requires the suffix_data (Base64URL encoded). Call the DidCreate transition","title":"The ```tyron``` smart-contract"},{"location":"implementation/smart-contracts/tyron/#the-tyron-smart-contract","text":"Zilliqa powers smart-contracts written in the Scilla programming language. The tyron smart-contract gets deployed with the following immutable fields: tyron_init: the address of the TyronInit smart contract contract_owner: the address of the user who is the owner of the contract The user must call the ContractInit transition that sets the: operation_cost foundation_address client_commission The input parameter is the client address that will manage the DID operations. These parameters can only change through the ContractInit transition, which calls the Initialize transition of the TyronInit contract Upcoming development: give client the option of offering discounts To create a DID, the Sidetree protocol requires the suffix_data (Base64URL encoded). Call the DidCreate transition","title":"The tyron smart-contract"},{"location":"operations/tyronZIL-operations/","text":"tyronZIL DID operations TyronZIL implements Sidetree delta-based operations to generate the DID-Suffix and the DID-Document as well as any following update, recover or deactivation by utilizing Sidetree public-key commitments to establish proof-of-control. Once the Sidetree operation request is validated, the DID-Client MUST submit the DID-State modifications to the user's Tyron-Smart-Contract, which is deployed by the DID-Create operation. The tyronZIL DID-Client performs the following operations: Create : How to generate a DID and its associated DID-Document. Plus how to save the DID on Zilliqa by deploying a Scilla smart-contract. Read : How to use a DID to request its DID-Document. This operation corresponds to the DID-Resolution process. Recover : To fully reset your DID-Document while keeping the same DID. Update : How to update verification methods/ service endpoints in the DID-Document. Deactivate : How to deactivate a DID, forever. It turns all DID-State variables to undefined. Sidetree operation type Conforming with the Sidetree protocol, tyronZIL DID operations MUST have a type equal to one variant of the OperationType enum, defined as follows: enum OperationType { Create = 'create', Recover = 'recover' Update = 'update', Deactivate = 'deactivate', }","title":"tyronZIL operations"},{"location":"operations/tyronZIL-operations/#tyronzil-did-operations","text":"TyronZIL implements Sidetree delta-based operations to generate the DID-Suffix and the DID-Document as well as any following update, recover or deactivation by utilizing Sidetree public-key commitments to establish proof-of-control. Once the Sidetree operation request is validated, the DID-Client MUST submit the DID-State modifications to the user's Tyron-Smart-Contract, which is deployed by the DID-Create operation. The tyronZIL DID-Client performs the following operations: Create : How to generate a DID and its associated DID-Document. Plus how to save the DID on Zilliqa by deploying a Scilla smart-contract. Read : How to use a DID to request its DID-Document. This operation corresponds to the DID-Resolution process. Recover : To fully reset your DID-Document while keeping the same DID. Update : How to update verification methods/ service endpoints in the DID-Document. Deactivate : How to deactivate a DID, forever. It turns all DID-State variables to undefined.","title":"tyronZIL DID operations"},{"location":"operations/tyronZIL-operations/#sidetree-operation-type","text":"Conforming with the Sidetree protocol, tyronZIL DID operations MUST have a type equal to one variant of the OperationType enum, defined as follows: enum OperationType { Create = 'create', Recover = 'recover' Update = 'update', Deactivate = 'deactivate', }","title":"Sidetree operation type"},{"location":"operations/CRUD/did-create/","text":"tyronZIL DID-Create operation A tyronZIL DID-Create operation is conformant with a Sidetree Create Operation, and its goal is to generate a brand new tyronZIL Decentralized Identifier. Follow these steps: 1. Verification methods tyronZIL-v0.4 supports 1 kind of verification method: 'publicKey' 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[] 2. Public-key commitments 2.1 For the public-key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY ) 3. Service endpoints Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[] 4. Document model Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service } 5. DID-State patch Put the previously generated document inside of a DID-State patch . For the DID-Create operation, the patch action is 'Replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction 6. Create Operation Delta Object 6.1 Using the DID-State patch and the update-commitment, generate an instance of the Create Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol and then encode it again as DELTA_HASH 7. Create Operation Suffix Data Object 7.1 Using the DELTA_HASH from the previous step, and the recovery-commitment, generate an instance of the Create Operation Suffix Data Object as follows: SUFFIX_DATA = { delta_hash: DELTA_HASH, recovery_commitment: RECOVERY_COMMITMENT } SUFFIX_DATA is of type SuffixDataModel Then stringify it and encode it with the data encoding scheme as ENCODED_SUFFIX_DATA . 8. Sidetree request 8.1 Generate the following object: SIDETREE_REQUEST = { suffix_data: ENCODED_SUFFIX_DATA, type: OperationType.Create, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 8.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library CreateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The didUniqueSuffix is generated by decoding the ENCODED_SUFFIX_DATA as a buffer, then hashing it with the hash algorithm & hash protocol and then encoding it again with the data encoding scheme . The type of operation: type: OperationType.Create The data used to generate the unique DID-Suffix: suffixData: SuffixDataModel The encoded string of the suffix data: encodedSuffixData: string The Create Operation Delta Object: delta: DeltaModel The encoded string of the delta: encodedDelta: string 9. Tyron-Smart-Contract Every tyronZIL DID MUST deploy a Scilla smart contract called the Tyron-Smart-Contract(TSM) , except when using the DID as an unpropagated Sidetree Long-Form DID-URI . The TSM is instantiated from the TyronInit smart-contract , currently deployed at this Zilliqa address: '0x75d8297b8bd2e35de1c17e19d2c13504de623793'. The client decodes and decompresses the TSM, and then deploys it with the user's Zilliqa address as the 'contract_owner'. To initialize their TSM, the user MUST call its 'ContractInit' transition and provide the address of the client. This transition sends a message to the 'Initialize' 'transition' of the TyronInit contract that knows how to set the operation cost, client commission and the address of the Pungtas Danish Foundation at the user's TSM-State. The Pungtas Danish Foundation will be the socio-economic enterprise developing Tyron Once the TSM gets initialized, the client MUST submit the DID-Create operation by calling the DidCreate transition, which takes as input the Decentralized Identifier, the encoded DID-Document, the update-commitment and the recovery commitment. The smart-contract then saves these in the TSM-State. The complete submission of a tyronZIL DID-Create operation (incl. the TSM deployment and initialization) consumes approximately 15,000 units of GAS (around 15 ZIL, currently less than 0.3 USD).","title":"Create"},{"location":"operations/CRUD/did-create/#tyronzil-did-create-operation","text":"A tyronZIL DID-Create operation is conformant with a Sidetree Create Operation, and its goal is to generate a brand new tyronZIL Decentralized Identifier. Follow these steps:","title":"tyronZIL DID-Create operation"},{"location":"operations/CRUD/did-create/#1-verification-methods","text":"tyronZIL-v0.4 supports 1 kind of verification method: 'publicKey' 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[]","title":"1. Verification methods"},{"location":"operations/CRUD/did-create/#2-public-key-commitments","text":"2.1 For the public-key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY )","title":"2. Public-key commitments"},{"location":"operations/CRUD/did-create/#3-service-endpoints","text":"Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[]","title":"3. Service endpoints"},{"location":"operations/CRUD/did-create/#4-document-model","text":"Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service }","title":"4. Document model"},{"location":"operations/CRUD/did-create/#5-did-state-patch","text":"Put the previously generated document inside of a DID-State patch . For the DID-Create operation, the patch action is 'Replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction","title":"5. DID-State patch"},{"location":"operations/CRUD/did-create/#6-create-operation-delta-object","text":"6.1 Using the DID-State patch and the update-commitment, generate an instance of the Create Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol and then encode it again as DELTA_HASH","title":"6. Create Operation Delta Object"},{"location":"operations/CRUD/did-create/#7-create-operation-suffix-data-object","text":"7.1 Using the DELTA_HASH from the previous step, and the recovery-commitment, generate an instance of the Create Operation Suffix Data Object as follows: SUFFIX_DATA = { delta_hash: DELTA_HASH, recovery_commitment: RECOVERY_COMMITMENT } SUFFIX_DATA is of type SuffixDataModel Then stringify it and encode it with the data encoding scheme as ENCODED_SUFFIX_DATA .","title":"7. Create Operation Suffix Data Object"},{"location":"operations/CRUD/did-create/#8-sidetree-request","text":"8.1 Generate the following object: SIDETREE_REQUEST = { suffix_data: ENCODED_SUFFIX_DATA, type: OperationType.Create, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 8.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library CreateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The didUniqueSuffix is generated by decoding the ENCODED_SUFFIX_DATA as a buffer, then hashing it with the hash algorithm & hash protocol and then encoding it again with the data encoding scheme . The type of operation: type: OperationType.Create The data used to generate the unique DID-Suffix: suffixData: SuffixDataModel The encoded string of the suffix data: encodedSuffixData: string The Create Operation Delta Object: delta: DeltaModel The encoded string of the delta: encodedDelta: string","title":"8. Sidetree request"},{"location":"operations/CRUD/did-create/#9-tyron-smart-contract","text":"Every tyronZIL DID MUST deploy a Scilla smart contract called the Tyron-Smart-Contract(TSM) , except when using the DID as an unpropagated Sidetree Long-Form DID-URI . The TSM is instantiated from the TyronInit smart-contract , currently deployed at this Zilliqa address: '0x75d8297b8bd2e35de1c17e19d2c13504de623793'. The client decodes and decompresses the TSM, and then deploys it with the user's Zilliqa address as the 'contract_owner'. To initialize their TSM, the user MUST call its 'ContractInit' transition and provide the address of the client. This transition sends a message to the 'Initialize' 'transition' of the TyronInit contract that knows how to set the operation cost, client commission and the address of the Pungtas Danish Foundation at the user's TSM-State. The Pungtas Danish Foundation will be the socio-economic enterprise developing Tyron Once the TSM gets initialized, the client MUST submit the DID-Create operation by calling the DidCreate transition, which takes as input the Decentralized Identifier, the encoded DID-Document, the update-commitment and the recovery commitment. The smart-contract then saves these in the TSM-State. The complete submission of a tyronZIL DID-Create operation (incl. the TSM deployment and initialization) consumes approximately 15,000 units of GAS (around 15 ZIL, currently less than 0.3 USD).","title":"9. Tyron-Smart-Contract"},{"location":"operations/CRUD/did-deactivate/","text":"tyronZIL DID-Deactivate operation A tyronZIL DID-Deactivate operation is conformant with a Sidetree Deactivate operation, and its goal is to deactivate the given tyronZIL DID and set its DID-State to 'deactivate'. Follow these steps: 0. User input Ask the user for the recovery-private key corresponding to the previous recovery-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to deactivate their DID. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the recovery-commitment in the TSM-State. 1. Deactivate Operation Signed Data Object 1.1 Use the recovery private-key to get the RECOVERY_KEY corresponding to the previous recovery-commitment. Then generate an instance of the Deactivate Operation Signed Data Object as follows: SIGNED_DATA = { did_suffix: did_tyronZIL, recovery_key: PREVIOUS_RECOVERY_KEY } SIGNED_DATA is of type DeactivateSignedDataModel 1.2 Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous recovery-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousRecoveryPrivateKey); 2. Sidetree request 2.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.deactivate } 1.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 2.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library DeactivateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Deactivate Operation Signed Data Object: signedDataModel: DeactivateSignedDataModel The compact JWS signature that deactivated the DID: signedDataJws: Jws 3. Tyron-Smart-Contract(TSM) Once the Sidetree Deactivate Operation has been successful, the client MUST submit a transaction that calls the 'DidDeactivate' transition of the user's TSM. The required parameter is the previous recovery-commitment. This transition sets the status field to 'deactivate' and all other DID-State fields to 'undefined'. After deactivation, the DID cannot be utilized again and trying to resolve it MUST throw a 'DidDeactivated' error. A tyronZIL DID-Deactivate operation consumes approximately 1,500 units of GAS (around 1.5 ZIL, currently less than 0.03 USD).","title":"Deactivate"},{"location":"operations/CRUD/did-deactivate/#tyronzil-did-deactivate-operation","text":"A tyronZIL DID-Deactivate operation is conformant with a Sidetree Deactivate operation, and its goal is to deactivate the given tyronZIL DID and set its DID-State to 'deactivate'. Follow these steps:","title":"tyronZIL DID-Deactivate operation"},{"location":"operations/CRUD/did-deactivate/#0-user-input","text":"Ask the user for the recovery-private key corresponding to the previous recovery-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to deactivate their DID. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the recovery-commitment in the TSM-State.","title":"0. User input"},{"location":"operations/CRUD/did-deactivate/#1-deactivate-operation-signed-data-object","text":"1.1 Use the recovery private-key to get the RECOVERY_KEY corresponding to the previous recovery-commitment. Then generate an instance of the Deactivate Operation Signed Data Object as follows: SIGNED_DATA = { did_suffix: did_tyronZIL, recovery_key: PREVIOUS_RECOVERY_KEY } SIGNED_DATA is of type DeactivateSignedDataModel 1.2 Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous recovery-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousRecoveryPrivateKey);","title":"1. Deactivate Operation Signed Data Object"},{"location":"operations/CRUD/did-deactivate/#2-sidetree-request","text":"2.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.deactivate } 1.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 2.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library DeactivateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Deactivate Operation Signed Data Object: signedDataModel: DeactivateSignedDataModel The compact JWS signature that deactivated the DID: signedDataJws: Jws","title":"2. Sidetree request"},{"location":"operations/CRUD/did-deactivate/#3-tyron-smart-contracttsm","text":"Once the Sidetree Deactivate Operation has been successful, the client MUST submit a transaction that calls the 'DidDeactivate' transition of the user's TSM. The required parameter is the previous recovery-commitment. This transition sets the status field to 'deactivate' and all other DID-State fields to 'undefined'. After deactivation, the DID cannot be utilized again and trying to resolve it MUST throw a 'DidDeactivated' error. A tyronZIL DID-Deactivate operation consumes approximately 1,500 units of GAS (around 1.5 ZIL, currently less than 0.03 USD).","title":"3. Tyron-Smart-Contract(TSM)"},{"location":"operations/CRUD/did-recover/","text":"tyronZIL DID-Recover operation A tyronZIL DID-Recover operation is conformant with a Sidetree Recover Operation, and its goal is to recover a tyronZIL DID and fully reset its DID-state, except for the Decentralized Identifier itself. This way, the user can keep using the same DID with brand new PKI. Follow these steps: 0. User input Ask the user for the recovery-private key corresponding to the previous recovery-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to recover their DID. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the recovery-commitment in the TSM-State. 1. Verification methods Generate new 'publicKey' verification methods. 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[] 2. Public-key commitments 2.1 For the public-key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY ) 3. Service endpoints Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[] 4. Document model Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service } 5. DID-State patch Put the previously generated document inside of a DID-State patch . For the DID-Recover operation, the patch action is 'Replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction 6. Recovery Operation Delta Object 6.1 Using the DID-State patch and the update-commitment, generate an instance of the Recovery Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol , and then encode it again as DELTA_HASH 7. Recovery Operation Signed Data Object 7.1 Using the DELTA_HASH , the RECOVERY_KEY corresponding to the previous recovery-commitment and the new recovery-commitment, generate an instance of the Recovery Operation Signed Data Object as follows: SIGNED_DATA = { delta_hash: DELTA_HASH, recovery_key: PREVIOUS_RECOVERY_KEY, recovery_commitment: NEW_RECOVERY_COMMITMENT } SIGNED_DATA is of type RecoverSignedDataModel 7.2 Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous recovery-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousRecoverPrivateKey); 8. Sidetree request 8.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.Recover, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 8.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library RecoverOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Recovery Operation Signed Data Object: signedDataModel: RecoverSignedDataModel The compact JWS signature that recovered the DID signedDataJws: Jws The Recovery Operation Delta Object: delta: DeltaModel The encoded delta: encodedDelta: string 9. Tyron-Smart-Contract(TSM) Once the Sidetree Recover Operation has been successful, continue by retrieving the DID-Document from the encoded delta. Then the client MUST submit a transaction that calls the 'DidRecover' transition of the user's TSM. The required parameters are the previous recovery-commitment, the new Base64URL-encoded DID-document, the new update-commitment and the new recovery-commitment. A tyronZIL DID-Recover operation consumes approximately 3,500 units of GAS (around 3.5 ZIL, currently less than 0.07 USD).","title":"Recover"},{"location":"operations/CRUD/did-recover/#tyronzil-did-recover-operation","text":"A tyronZIL DID-Recover operation is conformant with a Sidetree Recover Operation, and its goal is to recover a tyronZIL DID and fully reset its DID-state, except for the Decentralized Identifier itself. This way, the user can keep using the same DID with brand new PKI. Follow these steps:","title":"tyronZIL DID-Recover operation"},{"location":"operations/CRUD/did-recover/#0-user-input","text":"Ask the user for the recovery-private key corresponding to the previous recovery-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to recover their DID. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the recovery-commitment in the TSM-State.","title":"0. User input"},{"location":"operations/CRUD/did-recover/#1-verification-methods","text":"Generate new 'publicKey' verification methods. 1.1 Under the property 'publicKey', assing to its value an array of keys of type PublicKeyModel , generated using the operation key pair : publicKeys: PublicKeyModel[]","title":"1. Verification methods"},{"location":"operations/CRUD/did-recover/#2-public-key-commitments","text":"2.1 For the public-key commitments , first, generate two key-pairs: [UPDATE_KEY, UPDATE_PRIVATE_KEY] [RECOVERY_KEY, RECOVERY_PRIVATE_KEY] 2.2 Use the UPDATE_KEY to generate the update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 2.2 Use the RECOVERY_KEY to generate the recovery-commitment: RECOVERY_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( RECOVERY_KEY )","title":"2. Public-key commitments"},{"location":"operations/CRUD/did-recover/#3-service-endpoints","text":"Under the property 'service', assign to its value an array of service endpoint objects of type ServiceEndpointModel : service: ServiceEndpointModel[]","title":"3. Service endpoints"},{"location":"operations/CRUD/did-recover/#4-document-model","text":"Generate a document of type DocumentModel : DOCUMENT = { public_keys: publicKeys, service_endpoints: service }","title":"4. Document model"},{"location":"operations/CRUD/did-recover/#5-did-state-patch","text":"Put the previously generated document inside of a DID-State patch . For the DID-Recover operation, the patch action is 'Replace': PATCH = { action: PatchAction.Replace, document: DOCUMENT } PATCH is of type PatchModel , with a Replace PatchAction","title":"5. DID-State patch"},{"location":"operations/CRUD/did-recover/#6-recovery-operation-delta-object","text":"6.1 Using the DID-State patch and the update-commitment, generate an instance of the Recovery Operation Delta Object as follows: DELTA = { patches: [PATCH], updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 6.2 Stringify it and turn it into a buffer 6.3 Encode it with the data encoding scheme as ENCODED_DELTA 6.4 Hash it with the hash algorithm & hash protocol , and then encode it again as DELTA_HASH","title":"6. Recovery Operation Delta Object"},{"location":"operations/CRUD/did-recover/#7-recovery-operation-signed-data-object","text":"7.1 Using the DELTA_HASH , the RECOVERY_KEY corresponding to the previous recovery-commitment and the new recovery-commitment, generate an instance of the Recovery Operation Signed Data Object as follows: SIGNED_DATA = { delta_hash: DELTA_HASH, recovery_key: PREVIOUS_RECOVERY_KEY, recovery_commitment: NEW_RECOVERY_COMMITMENT } SIGNED_DATA is of type RecoverSignedDataModel 7.2 Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous recovery-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousRecoverPrivateKey);","title":"7. Recovery Operation Signed Data Object"},{"location":"operations/CRUD/did-recover/#8-sidetree-request","text":"8.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.Recover, delta: ENCODED_DELTA } 8.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 8.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library RecoverOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Recovery Operation Signed Data Object: signedDataModel: RecoverSignedDataModel The compact JWS signature that recovered the DID signedDataJws: Jws The Recovery Operation Delta Object: delta: DeltaModel The encoded delta: encodedDelta: string","title":"8. Sidetree request"},{"location":"operations/CRUD/did-recover/#9-tyron-smart-contracttsm","text":"Once the Sidetree Recover Operation has been successful, continue by retrieving the DID-Document from the encoded delta. Then the client MUST submit a transaction that calls the 'DidRecover' transition of the user's TSM. The required parameters are the previous recovery-commitment, the new Base64URL-encoded DID-document, the new update-commitment and the new recovery-commitment. A tyronZIL DID-Recover operation consumes approximately 3,500 units of GAS (around 3.5 ZIL, currently less than 0.07 USD).","title":"9. Tyron-Smart-Contract(TSM)"},{"location":"operations/CRUD/did-resolve/","text":"tyronZIL DID-Resolve operation DID-Resolution It corresponds to the READ operation of a Decentralized Identifier. The DID-Resolution function resolves a DID into its DID-Document by performing the process called DID-Resolution. A DID-Resolver is the software component that executes the DID-Resolution process. It takes a DID (and metadata) as input and produces a conforming DID-Document (and metadata) as output, which is called the DID-Resolution-Result. DID-Resolution variables for tyronZIL DIDs Input variables did : A conformant DID as a single string. This is the DID to resolve. This input is REQUIRED. network : The 'NetworkNamespace' referring to the testnet or the mainnet. tyronAddr : The Zilliqa address of the user's Tyron-Smart-Contract. In upcoming versions, the tyronAddr will get retrieved from a DNS-like smart-contract. metadata : The DID-Resolution input metadata is a structure consisting of input options to the resolve function in addition to the DID itself. This input is REQUIRED. The options control how the DID is resolved. TyronZIL-v0.4 only supports the 'Accept' option that defines if the result shall be the corresponding DID-Document with or without the Document-metadata. The former produces an output called DID-Resolution-Result. Output variables resolutionMetadata : A metadata structure consisting of values relating to the results of the DID-Resolution process. This structure is REQUIRED and MUST NOT be empty. This metadata typically changes between invocations of the resolve function as it represents data about the resolution process itself. TyronZIL's 'resolutionMetadata' refers to the Zilliqa's 'GetBlockchainInfo' method that returns the network statistics for the specified network at the time of the request. document : This MUST be the resolved DID-Document serialized in JSON format. documentMetadata : This structure contains metadata about the Decentralized Identifier of the DID-Document. It typically does not change between invocations of the resolve method unless the DID-Document changes. TyronZIL's 'DocumentMetadata' includes three properties: the 'contentType' equal to \"application/did+json\", the 'updateCommitment' and the 'recoveryCommitment'. Find the tyronZIL DID-Resolution method here Resolving a deactivated DID If a tyronZIL DID status is 'deactivate' in its corresponding Tyron-Smart-Contract-State, then the DID-Resolver MUST throw a 'DidDeactivated' error. DID-URL dereferencing DD-URL dereferencing is the process that returns the particular resource specified by the DID-URL. It can use the DID-Resolution process to fetch the DID-Document and then it performs additional processing on the DID-Document to return the dereferenced resource that was requested. The software component is called DID-URL-Dereferencer, and it takes as input a DID-URL, a DID-Document and a set of dereferencing options and returns the specific resource. The dereferencing options control how the resource is dereferenced. DID-URL dereferencing will be supported in future versions of tyronZIL","title":"Resolve"},{"location":"operations/CRUD/did-resolve/#tyronzil-did-resolve-operation","text":"","title":"tyronZIL DID-Resolve operation"},{"location":"operations/CRUD/did-resolve/#did-resolution","text":"It corresponds to the READ operation of a Decentralized Identifier. The DID-Resolution function resolves a DID into its DID-Document by performing the process called DID-Resolution. A DID-Resolver is the software component that executes the DID-Resolution process. It takes a DID (and metadata) as input and produces a conforming DID-Document (and metadata) as output, which is called the DID-Resolution-Result.","title":"DID-Resolution"},{"location":"operations/CRUD/did-resolve/#did-resolution-variables-for-tyronzil-dids","text":"","title":"DID-Resolution variables for tyronZIL DIDs"},{"location":"operations/CRUD/did-resolve/#input-variables","text":"did : A conformant DID as a single string. This is the DID to resolve. This input is REQUIRED. network : The 'NetworkNamespace' referring to the testnet or the mainnet. tyronAddr : The Zilliqa address of the user's Tyron-Smart-Contract. In upcoming versions, the tyronAddr will get retrieved from a DNS-like smart-contract. metadata : The DID-Resolution input metadata is a structure consisting of input options to the resolve function in addition to the DID itself. This input is REQUIRED. The options control how the DID is resolved. TyronZIL-v0.4 only supports the 'Accept' option that defines if the result shall be the corresponding DID-Document with or without the Document-metadata. The former produces an output called DID-Resolution-Result.","title":"Input variables"},{"location":"operations/CRUD/did-resolve/#output-variables","text":"resolutionMetadata : A metadata structure consisting of values relating to the results of the DID-Resolution process. This structure is REQUIRED and MUST NOT be empty. This metadata typically changes between invocations of the resolve function as it represents data about the resolution process itself. TyronZIL's 'resolutionMetadata' refers to the Zilliqa's 'GetBlockchainInfo' method that returns the network statistics for the specified network at the time of the request. document : This MUST be the resolved DID-Document serialized in JSON format. documentMetadata : This structure contains metadata about the Decentralized Identifier of the DID-Document. It typically does not change between invocations of the resolve method unless the DID-Document changes. TyronZIL's 'DocumentMetadata' includes three properties: the 'contentType' equal to \"application/did+json\", the 'updateCommitment' and the 'recoveryCommitment'. Find the tyronZIL DID-Resolution method here","title":"Output variables"},{"location":"operations/CRUD/did-resolve/#resolving-a-deactivated-did","text":"If a tyronZIL DID status is 'deactivate' in its corresponding Tyron-Smart-Contract-State, then the DID-Resolver MUST throw a 'DidDeactivated' error.","title":"Resolving a deactivated DID"},{"location":"operations/CRUD/did-resolve/#did-url-dereferencing","text":"DD-URL dereferencing is the process that returns the particular resource specified by the DID-URL. It can use the DID-Resolution process to fetch the DID-Document and then it performs additional processing on the DID-Document to return the dereferenced resource that was requested. The software component is called DID-URL-Dereferencer, and it takes as input a DID-URL, a DID-Document and a set of dereferencing options and returns the specific resource. The dereferencing options control how the resource is dereferenced. DID-URL dereferencing will be supported in future versions of tyronZIL","title":"DID-URL dereferencing"},{"location":"operations/CRUD/did-update/","text":"tyronZIL DID-Update operation A tyronZIL DID-Update operation is conformant with a Sidetree Update Operation, and its goal is to update a tyronZIL DID according to a predetermined set of patches. Follow these steps: 0. User input Ask the user for the update-private key corresponding to the previous update-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to update their DID and the corresponding DID-State. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the update-commitment in the TSM-State. 1. Patch action The user can choose among these patch actions . 2. New update-commitment 2.1 Generate the update keys: [UPDATE_KEY, UPDATE_PRIVATE_KEY] 2.2 Generate the new update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY ) 3. Generate the DID-state patch array PATCH = { action: PatchAction, public_keys?: PublicKeyModel[] | string[]; //array of key to add OR key-ids to remove ids?: string []; //array of service ids to remove those services service_endpoints?: ServiceEndpointModel[]; //when adding services }[] PATCH is of type PatchModel , and the action is any of the PatchAction variants from step 1 4. Update Operation Delta Object 4.1 Using the DID-State patch and the update-commitment, generate an instance of the Update Operation Delta Object as follows: DELTA = { patches: PATCH, updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 4.2 Stringify it and turn it into a buffer 4.3 Encode it with the data encoding scheme as ENCODED_DELTA 4.4 Hash it with the hash algorithm & hash protocol , and then encode it again as DELTA_HASH 5. Update Operation Signed Data Object 5.1 Using the DELTA_HASH , and the UPDATE_KEY from the previous update operation, generate an instance of the Update Operation Signed Data Object as follows: SIGNED_DATA = { delta_hash: DELTA_HASH, update_key: PREVIOUS_UPDATE_KEY } SIGNED_DATA is of type UpdateSignedDataModel Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous update-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousUpdatePrivateKey); 6. Sidetree request 6.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.Update, delta: ENCODED_DELTA } 6.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 6.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library UpdateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Update Operation Signed Data Object: signedDataModel: UpdateSignedDataModel The compact JWS signature that updated the DID signedDataJws: Jws The Update Operation Delta Object: delta: DeltaModel The encoded delta: encodedDelta: string 7. Tyron-Smart-Contract(TSM) Once the Sidetree Update Operation has been successful, continue by retrieving the updated DID-Document. Then the client MUST submit a transaction that calls the 'DidUpdate' transition of the user's TSM. The required parameters are the previous update-commitment, the new Base64URL-encoded DID-document and the new update-commitment. A tyronZIL DID-Update operation consumes approximately 2,500 units of GAS (around 2.5 ZIL, currently less than 0.05 USD).","title":"Update"},{"location":"operations/CRUD/did-update/#tyronzil-did-update-operation","text":"A tyronZIL DID-Update operation is conformant with a Sidetree Update Operation, and its goal is to update a tyronZIL DID according to a predetermined set of patches. Follow these steps:","title":"tyronZIL DID-Update operation"},{"location":"operations/CRUD/did-update/#0-user-input","text":"Ask the user for the update-private key corresponding to the previous update-commitment, as well as the address of the user's Tyron-Smart-Contract(TSM) to update their DID and the corresponding DID-State. The client MUST fetch the TSM-State and check that the key given by the user corresponds to the update-commitment in the TSM-State.","title":"0. User input"},{"location":"operations/CRUD/did-update/#1-patch-action","text":"The user can choose among these patch actions .","title":"1. Patch action"},{"location":"operations/CRUD/did-update/#2-new-update-commitment","text":"2.1 Generate the update keys: [UPDATE_KEY, UPDATE_PRIVATE_KEY] 2.2 Generate the new update-commitment: UPDATE_COMMITMENT = Multihash .canonicalize ThenHash ThenEncode ( UPDATE_KEY )","title":"2. New update-commitment"},{"location":"operations/CRUD/did-update/#3-generate-the-did-state-patch-array","text":"PATCH = { action: PatchAction, public_keys?: PublicKeyModel[] | string[]; //array of key to add OR key-ids to remove ids?: string []; //array of service ids to remove those services service_endpoints?: ServiceEndpointModel[]; //when adding services }[] PATCH is of type PatchModel , and the action is any of the PatchAction variants from step 1","title":"3. Generate the DID-state patch array"},{"location":"operations/CRUD/did-update/#4-update-operation-delta-object","text":"4.1 Using the DID-State patch and the update-commitment, generate an instance of the Update Operation Delta Object as follows: DELTA = { patches: PATCH, updateCommitment: UPDATE_COMMITMENT } DELTA is of type DeltaModel Then apply the following operations to the object: 4.2 Stringify it and turn it into a buffer 4.3 Encode it with the data encoding scheme as ENCODED_DELTA 4.4 Hash it with the hash algorithm & hash protocol , and then encode it again as DELTA_HASH","title":"4. Update Operation Delta Object"},{"location":"operations/CRUD/did-update/#5-update-operation-signed-data-object","text":"5.1 Using the DELTA_HASH , and the UPDATE_KEY from the previous update operation, generate an instance of the Update Operation Signed Data Object as follows: SIGNED_DATA = { delta_hash: DELTA_HASH, update_key: PREVIOUS_UPDATE_KEY } SIGNED_DATA is of type UpdateSignedDataModel Then sign this object as a e256k compact JWS, signing it with the private-key corresponding to the previous update-commitment. const SIGNED_DATA_JWS = await Cryptography.signUsingEs256k(SIGNED_DATA, previousUpdatePrivateKey);","title":"5. Update Operation Signed Data Object"},{"location":"operations/CRUD/did-update/#6-sidetree-request","text":"6.1 Generate the following object: SIDETREE_REQUEST = { did_suffix: did_tyronZIL, signed_data: SIGNED_DATA_JWS, type: OperationType.Update, delta: ENCODED_DELTA } 6.2 Stringify it and turn it into a buffer as SIDETREE_REQUEST_BUFFER 6.3 Process the SIDETREE_REQUEST_BUFFER with the Sidetree's library UpdateOperation, which returns a class with the following properties: The original request buffer sent by the requester: operationBuffer: Buffer The unique suffix of the DID, globally unique: didUniqueSuffix: string The data used to generate the Update Operation Signed Data Object: signedDataModel: UpdateSignedDataModel The compact JWS signature that updated the DID signedDataJws: Jws The Update Operation Delta Object: delta: DeltaModel The encoded delta: encodedDelta: string","title":"6. Sidetree request"},{"location":"operations/CRUD/did-update/#7-tyron-smart-contracttsm","text":"Once the Sidetree Update Operation has been successful, continue by retrieving the updated DID-Document. Then the client MUST submit a transaction that calls the 'DidUpdate' transition of the user's TSM. The required parameters are the previous update-commitment, the new Base64URL-encoded DID-document and the new update-commitment. A tyronZIL DID-Update operation consumes approximately 2,500 units of GAS (around 2.5 ZIL, currently less than 0.05 USD).","title":"7. Tyron-Smart-Contract(TSM)"},{"location":"scheme/did-scheme/","text":"DID-Scheme A DID-Scheme is the formal syntax of a Decentralized Identifier. Generic W3C DID-Scheme It is a URI scheme conformant with RFC3986, Uniform Resource Identifier (URI): Generic Syntax . The following is the ABNF definition with ALPHA and DIGIT: Using the syntax in RFC5234, Augmented BNF for Syntax Specifications: ABNF . Generic rule names not defined there, are defined in RFC3986 did = \"did:\" method-name \":\" method-specific-id method-name = 1*method-char method-char = %x61-7A / DIGIT method-specific-id = *( *idchar \":\" ) 1*idchar idchar = ALPHA / DIGIT / \".\" / \"-\" / \"_\" Both the scheme identifier (did) and the method name MUST be an ASCII lowercase string . tyronZIL DID-Scheme The tyronZIL DID-Method defines its method-name as \"tyron\" and the method-specific-id syntax as hierarchically partitioned: method-name = \"tyron\" method-specific-id = blockchain-namespace \":\" network-namespace \":\" did-suffix blockchain-namespace = \"zil:\" network-namespace = 1*idchar did-suffix = 1*idchar The network-namespace MUST be one of the following variants: enum NetworkNamespace { Mainnet = 'main:', Testnet = 'test:', } Example of a tyronZIL DID : did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g DID-Suffix The DID-Suffix MUST be globally unique and generated as specified in the tyronZIL DID-create operation . Normalization The DID-Scheme name (did) MUST be lowercase. The DID-Method name (tyron) MUST be lowercase. TyronZIL's specific-id MUST follow the rules stated above. Persistence A tyronZIL DID is bound exclusively and permanently to its one and only subject , even after deactivation. Implementation The tyronZIL-js DID-Scheme corresponds to the class TyronZILScheme , which has the following properties: schemeIdentifier = 'did:' methodName = 'tyron:' blockchain = 'zil:' network = NetworkNamespace didUniqueSuffix: string did_tyronZIL: string did_tyronZIL is the fully expressed tyronZIL DID","title":"DID-Scheme"},{"location":"scheme/did-scheme/#did-scheme","text":"A DID-Scheme is the formal syntax of a Decentralized Identifier.","title":"DID-Scheme"},{"location":"scheme/did-scheme/#generic-w3c-did-scheme","text":"It is a URI scheme conformant with RFC3986, Uniform Resource Identifier (URI): Generic Syntax . The following is the ABNF definition with ALPHA and DIGIT: Using the syntax in RFC5234, Augmented BNF for Syntax Specifications: ABNF . Generic rule names not defined there, are defined in RFC3986 did = \"did:\" method-name \":\" method-specific-id method-name = 1*method-char method-char = %x61-7A / DIGIT method-specific-id = *( *idchar \":\" ) 1*idchar idchar = ALPHA / DIGIT / \".\" / \"-\" / \"_\" Both the scheme identifier (did) and the method name MUST be an ASCII lowercase string .","title":"Generic W3C DID-Scheme"},{"location":"scheme/did-scheme/#tyronzil-did-scheme","text":"The tyronZIL DID-Method defines its method-name as \"tyron\" and the method-specific-id syntax as hierarchically partitioned: method-name = \"tyron\" method-specific-id = blockchain-namespace \":\" network-namespace \":\" did-suffix blockchain-namespace = \"zil:\" network-namespace = 1*idchar did-suffix = 1*idchar The network-namespace MUST be one of the following variants: enum NetworkNamespace { Mainnet = 'main:', Testnet = 'test:', } Example of a tyronZIL DID : did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g","title":"tyronZIL DID-Scheme"},{"location":"scheme/did-scheme/#did-suffix","text":"The DID-Suffix MUST be globally unique and generated as specified in the tyronZIL DID-create operation .","title":"DID-Suffix"},{"location":"scheme/did-scheme/#normalization","text":"The DID-Scheme name (did) MUST be lowercase. The DID-Method name (tyron) MUST be lowercase. TyronZIL's specific-id MUST follow the rules stated above.","title":"Normalization"},{"location":"scheme/did-scheme/#persistence","text":"A tyronZIL DID is bound exclusively and permanently to its one and only subject , even after deactivation.","title":"Persistence"},{"location":"scheme/did-scheme/#implementation","text":"The tyronZIL-js DID-Scheme corresponds to the class TyronZILScheme , which has the following properties: schemeIdentifier = 'did:' methodName = 'tyron:' blockchain = 'zil:' network = NetworkNamespace didUniqueSuffix: string did_tyronZIL: string did_tyronZIL is the fully expressed tyronZIL DID","title":"Implementation"},{"location":"scheme/did-url-syntax/","text":"tyronZIL DID-URL syntax The following is the ABNF definition using the syntax in RFC5324 : The path-abempty and fragment components are identical to the ABNF rules defined in RFC3986 The did-query component is derived from the query ABNF rule did-url = did path-abempty [ \"?\" did-query ] [ \"#\" fragment ] did-query = param *( \"&\" param ) param = param-name \"=\" param-value param-name = 1*pchar param-value = *pchar Path To be used to address resources available through a service endpoint. It MUST conform to the path-abempty ABFN rule in RFC3986 . Query The W3C did-query component derives from the query ABFN rule. It MUST be used with DID parameters as follows. DID-URL parameters These parameters are part of the query component of the DID-URL to specify what resource is requested. W3C DID parameter-names: hl : A resource hash of the DID-Document to add integrity protection. service : Identifies a service from the DID-Document by service ID. did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?service=agentId1 version-id : Identifies a specific version of the DID-Document to be resolved. version-time : Identifies a specific version timestamp of the DID-Document to be resolved (the doc that was valid at that particular time). did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?version-time=2020-09-07T17:00:00Z Additional parameters MUST be prefixed by the method name 'tyron', e.g.: 'tyron-dns'. TyronZIL method-specific parameter names MAY be used by other DID methods. Method-specific parameter names MAY be combined with generic parameter names in any order. Method-specific parameter namespaces MAY include colons to be partitioned hierarchically. At the current version, the tyronZIL-Method does not support DID-URL parameters, EXCEPT the following: Sidetree Long-Form DID By using a DID with the DID-URL parameter sidetree-initial-state , a tyronZIL user can utilize their Long-Form DID URI . It is composed by the Create Operation Suffix Data Object and the Create Operation Delta Object , separated by a period ' . ': did:tyron:zil:test:EiApcQfeTVd3aCGb07Cj3MfZBaBv6KA7kdCAokuM6qxNWQ?sidetree-initial-state=eyJkZWx0YV9oYXNoIjoiRWlCWS1yRm1NVDNESlV0ZktaYnNqSFJyVXRjbXVCUHZ2M2htemhZb3pia3g0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUF0LVJpV29uU1Nsc1U5SWVsbUY3MHZsZ1oybVpyU29QT0Y2RWJybmMya1dBIn0.eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoicHJpbWFyeVNpZ25pbmdLZXkiLCJ0eXBlIjoiRWNkc2FTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE5IiwiandrIjp7Imt0eSI6IkVDIiwiY3J2Ijoic2VjcDI1NmsxIiwieCI6IjFsQlBRaGtoNS02U3plNUlkbWZFeUZWVXdXUWFsYTVjcE5QWkJ6bU4zd1kiLCJ5IjoidEdYTkZIWDhjMkVsdkdyS2xPeHdxOXNHUDFVVFh2aW1SZmJUQy1yd3F5RSIsImtpZCI6IkplOEVOSk4ydm1oNVAwS0FXeEVwbTJQSllaMjBPZzNNSlFGSm1kdVE2T0EifSwicHVycG9zZSI6WyJnZW5lcmFsIiwiYXV0aCJdfV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJpZCI6InR5cm9uWklMLXdlYnNpdGUiLCJ0eXBlIjoibWV0aG9kLXNwZWNpZmljYXRpb24iLCJlbmRwb2ludCI6Imh0dHBzOi8vdHlyb25aSUwuY29tIn0seyJpZCI6IlpJTC1hZGRyZXNzIiwidHlwZSI6ImNyeXB0b2N1cnJlbmN5LWFkZHJlc3MiLCJlbmRwb2ludCI6InppbDFlZ3ZqNmtldGZ5ZHk0OHVxenU4cXBoaGo1dzR4cmtyYXR2ODVodCJ9XX19XSwidXBkYXRlQ29tbWl0bWVudCI6IkVpQjFnZkZtUVY4b0w3ZFJ5S3hrLU9xeEJ5amJwNTZkd1otNm9sRkpfRWRlWkEifQ Find the tyronZIL DID-URL implementation here Fragment A W3C DID fragment is used as a method-independent reference into the DID-Document to identify a component of the document by ID, e.g. a specific public key or service endpoint. It MUST conform to the generic URI fragment syntax in RFC3986 .","title":"DID-URL syntax"},{"location":"scheme/did-url-syntax/#tyronzil-did-url-syntax","text":"The following is the ABNF definition using the syntax in RFC5324 : The path-abempty and fragment components are identical to the ABNF rules defined in RFC3986 The did-query component is derived from the query ABNF rule did-url = did path-abempty [ \"?\" did-query ] [ \"#\" fragment ] did-query = param *( \"&\" param ) param = param-name \"=\" param-value param-name = 1*pchar param-value = *pchar","title":"tyronZIL DID-URL syntax"},{"location":"scheme/did-url-syntax/#path","text":"To be used to address resources available through a service endpoint. It MUST conform to the path-abempty ABFN rule in RFC3986 .","title":"Path"},{"location":"scheme/did-url-syntax/#query","text":"The W3C did-query component derives from the query ABFN rule. It MUST be used with DID parameters as follows.","title":"Query"},{"location":"scheme/did-url-syntax/#did-url-parameters","text":"These parameters are part of the query component of the DID-URL to specify what resource is requested. W3C DID parameter-names: hl : A resource hash of the DID-Document to add integrity protection. service : Identifies a service from the DID-Document by service ID. did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?service=agentId1 version-id : Identifies a specific version of the DID-Document to be resolved. version-time : Identifies a specific version timestamp of the DID-Document to be resolved (the doc that was valid at that particular time). did:tyron:zil:test:EiAT_GxAt7gBozHlw2B1i7mfQaaORL3NOfFQr9FUt7jp6g?version-time=2020-09-07T17:00:00Z Additional parameters MUST be prefixed by the method name 'tyron', e.g.: 'tyron-dns'. TyronZIL method-specific parameter names MAY be used by other DID methods. Method-specific parameter names MAY be combined with generic parameter names in any order. Method-specific parameter namespaces MAY include colons to be partitioned hierarchically. At the current version, the tyronZIL-Method does not support DID-URL parameters, EXCEPT the following:","title":"DID-URL parameters"},{"location":"scheme/did-url-syntax/#sidetree-long-form-did","text":"By using a DID with the DID-URL parameter sidetree-initial-state , a tyronZIL user can utilize their Long-Form DID URI . It is composed by the Create Operation Suffix Data Object and the Create Operation Delta Object , separated by a period ' . ': did:tyron:zil:test:EiApcQfeTVd3aCGb07Cj3MfZBaBv6KA7kdCAokuM6qxNWQ?sidetree-initial-state=eyJkZWx0YV9oYXNoIjoiRWlCWS1yRm1NVDNESlV0ZktaYnNqSFJyVXRjbXVCUHZ2M2htemhZb3pia3g0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUF0LVJpV29uU1Nsc1U5SWVsbUY3MHZsZ1oybVpyU29QT0Y2RWJybmMya1dBIn0.eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoicHJpbWFyeVNpZ25pbmdLZXkiLCJ0eXBlIjoiRWNkc2FTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE5IiwiandrIjp7Imt0eSI6IkVDIiwiY3J2Ijoic2VjcDI1NmsxIiwieCI6IjFsQlBRaGtoNS02U3plNUlkbWZFeUZWVXdXUWFsYTVjcE5QWkJ6bU4zd1kiLCJ5IjoidEdYTkZIWDhjMkVsdkdyS2xPeHdxOXNHUDFVVFh2aW1SZmJUQy1yd3F5RSIsImtpZCI6IkplOEVOSk4ydm1oNVAwS0FXeEVwbTJQSllaMjBPZzNNSlFGSm1kdVE2T0EifSwicHVycG9zZSI6WyJnZW5lcmFsIiwiYXV0aCJdfV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJpZCI6InR5cm9uWklMLXdlYnNpdGUiLCJ0eXBlIjoibWV0aG9kLXNwZWNpZmljYXRpb24iLCJlbmRwb2ludCI6Imh0dHBzOi8vdHlyb25aSUwuY29tIn0seyJpZCI6IlpJTC1hZGRyZXNzIiwidHlwZSI6ImNyeXB0b2N1cnJlbmN5LWFkZHJlc3MiLCJlbmRwb2ludCI6InppbDFlZ3ZqNmtldGZ5ZHk0OHVxenU4cXBoaGo1dzR4cmtyYXR2ODVodCJ9XX19XSwidXBkYXRlQ29tbWl0bWVudCI6IkVpQjFnZkZtUVY4b0w3ZFJ5S3hrLU9xeEJ5amJwNTZkd1otNm9sRkpfRWRlWkEifQ Find the tyronZIL DID-URL implementation here","title":"Sidetree Long-Form DID"},{"location":"scheme/did-url-syntax/#fragment","text":"A W3C DID fragment is used as a method-independent reference into the DID-Document to identify a component of the document by ID, e.g. a specific public key or service endpoint. It MUST conform to the generic URI fragment syntax in RFC3986 .","title":"Fragment"}]}